#include <stdio.h>
#include <memory.h>

/*
 Chess Move Generator,
 a part of the Buzz OpenSource chess engine, released by Pradu Kannan
 http://pradu.us/old/Nov27_2008/Buzz/

 Fast and simple magic-bitboard generator source,
    (GCC compiler v.6.3.0 on Win32 - ok)
*/

//#define KING_MOVEGEN1 /*Generates attacksTo squares around the king.*/
#define KING_MOVEGEN2 /*Ands out attacks from squares around the king.*/

typedef unsigned long long  U64;

#define C64(constantU64) (unsigned long long)constantU64

//define boolean types and constants
typedef unsigned char bool;
#define true	1
#define false   0

#define abs(x) ((x)>=0?(x):-(x))

//A move
typedef unsigned int move;

/*********************Format of a Move**************************
Bits    (6)	0-5     are for the "to square".
Bits    (3)	6-8     are for the "capture piece".
Bits    (3)	9-11    are for the "moving piece".
Bits    (6)	12-17   are for the "from square".
Bits    (3)	18-20   are for the "promoting piece".
Bits    (6) 21-26   is for the "enpassant pawn being captured"
Bit     (1) 21      is for "kingside castling"
Bit     (1) 22      is for "queenside castling"
Bits    (5) 27-31   Extra info that will be ignored by makemove
****************************************************************/

//Define the colors
#define WHITE  0
#define BLACK  1
#define NOSIDE 2

//macros to help encode data X into a move
#define encodeTo(X)         ((move)X)
#define encodeCapture(X)    (((move)X)<<6)
#define encodePiece(X)      (((move)X)<<9)
#define encodeFrom(X)       (((move)X)<<12)
#define encodePromotion(X)  (((move)X)<<18)
#define encodeEP(X)         (((move)X)<<21)
#define encodeExtra(X)      (((move)X)<<27)

//macros to help extract data from move X
#define extractTo(m)        ((m)&0x3F)
#define extractCapture(m)   (((m)>>6)&7)
#define extractPiece(m)     (((m)>>9)&7)
#define extractFrom(m)      (((m)>>12)&0x3F)
#define extractPromotion(m) (((m)>>18)&7)
#define extractEP(m)	    (((m)>>21)&0x3F)
#define extractCastling(m)  (((m)>>21)&7)
#define extractExtra(m)     ((m)>>27)

#define stripMove(m)        ((m)&0x7FFFFFF)

//castling moves
#define KingsideCastle             0x201C00
#define QueensideCastle            0x401C00

//Definition of a move is in board.h
#define	MAX_MOVECHOICES 256

//a scored move
typedef struct _smove
{
	move m;
	int score;
}smove;

//a move list
typedef struct _moveList
{
	smove moves[MAX_MOVECHOICES];
	unsigned int moveCount;
}moveList;

//The squares - I didn't want to use enum to make these general purpose
#define A1  0
#define B1  1
#define C1  2
#define D1  3
#define E1  4
#define F1  5
#define G1  6
#define H1  7
#define A2  8
#define B2  9
#define C2 10
#define D2 11
#define E2 12
#define F2 13
#define G2 14
#define H2 15
#define A3 16
#define B3 17
#define C3 18
#define D3 19
#define E3 20
#define F3 21
#define G3 22
#define H3 23
#define A4 24
#define B4 25
#define C4 26
#define D4 27
#define E4 28
#define F4 29
#define G4 30
#define H4 31
#define A5 32
#define B5 33
#define C5 34
#define D5 35
#define E5 36
#define F5 37
#define G5 38
#define H5 39
#define A6 40
#define B6 41
#define C6 42
#define D6 43
#define E6 44
#define F6 45
#define G6 46
#define H6 47
#define A7 48
#define B7 49
#define C7 50
#define D7 51
#define E7 52
#define F7 53
#define G7 54
#define H7 55
#define A8 56
#define B8 57
#define C8 58
#define D8 59
#define E8 60
#define F8 61
#define G8 62
#define H8 63

//Files and ranks
#define FILEA 0
#define FILEB 1
#define FILEC 2
#define FILED 3
#define FILEE 4
#define FILEF 5
#define FILEG 6
#define FILEH 7
#define RANK1 0
#define RANK2 1
#define RANK3 2
#define RANK4 3
#define RANK5 4
#define RANK6 5
#define RANK7 6
#define RANK8 7

//Given the square number X
#define FILE(X) ((X)%8)
#define RANK(X) ((X)/8)

//Get the file bitboard for a file or rank
#define FILEBB(file) (C64(0x0101010101010101)<<(file))
#define RANKBB(rank) (C64(0xFF)<<(rank))

//Flip a square vertically or horizontally
#define FLIPV(X) ((X)^56) /*Example: square 0 becomes 56*/
#define FLIPH(X) ((X)^7)  /*Example: square 0 becomes  7*/



/*******************Castling Format*********************************************
 *(White KingSide) (White QueenSide) (Black KingSide) (Black QueenSide)
 *If black can castle on both sides and white can castle only on kingside, then
 *the number would be 0111 in binary.
 *
 *BK - Black Kingside
 *BQ - Black Queenside
 *WK - White Kingside
 *WQ - White Queenside
 ******************************************************************************/

#define KINGSIDE	0
#define QUEENSIDE	1

//castlings
#define WK 1 // 0001
#define WQ 2 // 0010
#define BK 4 // 0100
#define BQ 8 // 1000

//castlings for each side
#define BCASTLE	(BK|BQ) //(1100)
#define WCASTLE	(WK|WQ) //(0011)

//some defines for castling privilages
#define canCastle(pos,side) ((side)?((pos).castling)>>2:((pos).castling)&0x3)
#define canCastleWhite(pos) (((pos).castling)&0x3)
#define canCastleBlack(pos) (((pos).castling)>>2)

#define canCastleKingside(pos,side)  (canCastle(pos,side)&0x1)
#define canCastleQueenside(pos,side)  (canCastle(pos,side)&0x1)

//finding the column and row number of a square
#define COL(X) ((X)&0x7) /* X%8 */
#define ROW(X) ((X)>>3)  /* X/8 */


//First off the pieces
#define P 0
#define N 1
#define B 2
#define R 3
#define Q 4
#define K 5
#define NOPIECE 6
#define E NOPIECE

#define NUMPIECETYPES 6

//the board structure
typedef struct _board //104 bytes
{
	U64   AllPieces;                 //All the pieces on the board
	U64   PiecesSide[2];             //All the pieces belonging to each side
	U64   Pieces[NUMPIECETYPES];     //Specific pieces on the board eg Pieces[R]
	U64   hashkey;                   //the hash key for the transposition table
	unsigned int  recogsig;          //the recognizer signature
	unsigned char PieceTypes[64];    //All the piece types according to squares
	unsigned char KingPos[2];        //King position for a side
	unsigned char EP;                //The enpassant square
	unsigned char castling;          //Castling privilages - format defined below
	unsigned char fifty;             //Fifty move count
	bool side;                       //the side to play
	bool xside;                      //the side opposite to play
}board;

#define copyboardTo(pos2,pos) memcpy(pos2,pos,sizeof(board));

#define piecesSide(pos,piece)   ((pos).Pieces[(piece)]&(pos).PiecesSide[(pos).side])
#define piecesXSide(pos,piece)  ((pos).Pieces[(piece)]&(pos).PiecesSide[(pos).xside])
#define piecesWHITE(pos,piece)   ((pos).Pieces[(piece)]&(pos).PiecesSide[WHITE])
#define piecesBLACK(pos,piece)   ((pos).Pieces[(piece)]&(pos).PiecesSide[BLACK])


#define Pmoves(square, side) Pmoves[side][square]
#define Pcaps(square, side) Pcaps[side][square]
#define Kmoves(square) Kmoves[square]
#define Nmoves(square) Nmoves[square]
#define Rmoves(square,occupancy) Rmagic(square,occupancy)
#define Bmoves(square,occupancy) Bmagic(square,occupancy)
#define Qmoves(square,occupancy) Qmagic(square,occupancy)

#define BmovesNoOcc(square) BmovesNoOcc[square]
#define RmovesNoOcc(square) RmovesNoOcc[square]
#define QmovesNoOcc(square) (BmovesNoOcc(square)|RmovesNoOcc(square))

#define inBetween(sq1,sq2) inBetween[sq1][sq2]
#define lineOf(sq1,sq2) lineOf[sq1][sq2]


//gets all attackers to a square from both sides
#define attacksToB(pos,square) (Bmoves(square,(pos).AllPieces) & (pos).Pieces[B])
#define attacksToR(pos,square) (Rmoves(square,(pos).AllPieces) & (pos).Pieces[R])
#define attacksToQ(pos,square) (Qmoves(square,(pos).AllPieces) & (pos).Pieces[Q])
#define attacksToRBQ(pos,square) ((Bmoves(square,(pos).AllPieces) & ((pos).Pieces[B]|(pos).Pieces[Q])) | (Rmoves(square,(pos).AllPieces) & ((pos).Pieces[R]|(pos).Pieces[Q])))
#define attacksToN(pos,square) (Nmoves(square) & (pos).Pieces[N])
#define attacksToK(pos,square) (Kmoves(square) & (pos).Pieces[K])

//pawn attackers from a certain side (attackers from a side, not the guy being attacked)
#define attacksToP(pos,square,side) (Pcaps[!(side)][square]&((pos).Pieces[P]&(pos).PiecesSide[side]))

#define attacksTo(pos,square) ((Bmoves(square,(pos).AllPieces) & ((pos).Pieces[B]|(pos).Pieces[Q]))|(Rmoves(square,(pos).AllPieces)& ((pos).Pieces[R]|(pos).Pieces[Q]))|(Nmoves[square]&(pos).Pieces[N])|(Kmoves[square]&(pos).Pieces[K])|(Pcaps[WHITE][square]&((pos).Pieces[P]&(pos).PiecesSide[BLACK]))|(Pcaps[BLACK][square]&((pos).Pieces[P]&(pos).PiecesSide[WHITE])))
//returns whether the side is attacked at the square - also retruns locatin of all attackers
#define isAttacked(pos,square,side) (attacksTo(pos,square)& (pos).PiecesSide[!(side)])
//returns whether the side is in check and the pieces checking
#define inCheck(pos,side) (attacksToP(pos,(pos).KingPos[side],!(side)) | (((pos).PiecesSide[!(side)]) & (attacksToRBQ(pos,(pos).KingPos[side]) | attacksToN(pos,(pos).KingPos[side]) | attacksToK(pos,(pos).KingPos[side]) )))

#define attacksToOcc(pos,square,occ) ((Bmoves(square,(occ)) & ((pos).Pieces[B]|(pos).Pieces[Q]))|(Rmoves(square,(occ))& ((pos).Pieces[R]|(pos).Pieces[Q]))|(Nmoves[square]&(pos).Pieces[N])|(Kmoves[square]&(pos).Pieces[K])|(Pcaps[WHITE][square]&((pos).Pieces[P]&(pos).PiecesSide[BLACK]))|(Pcaps[BLACK][square]&((pos).Pieces[P]&(pos).PiecesSide[WHITE])))
#define attacksBQRToOcc(pos,square,occ) ((Bmoves(square,(occ)) & ((pos).Pieces[B]|(pos).Pieces[Q]))|(Rmoves(square,(occ))& ((pos).Pieces[R]|(pos).Pieces[Q])))
#define isAttackedOcc(pos,square,side,occ) (attacksToOcc(pos,square,occ) & (pos).PiecesSide[!(side)])

//white and black squares
#define WHITESQUARES C64(0x55AA55AA55AA55AA)
#define BLACKSQUARES C64(0xAA55AA55AA55AA55)

//defining full and empty U64 numbers
#define U64FULL     C64(0xFFFFFFFFFFFFFFFF)
#define U64EMPTY    C64(0x0000000000000000)

const U64 Pmoves[2][64]=
{
	{
		C64(0x0000000000000100), C64(0x0000000000000200), C64(0x0000000000000400), C64(0x0000000000000800),
		C64(0x0000000000001000), C64(0x0000000000002000), C64(0x0000000000004000), C64(0x0000000000008000),
		C64(0x0000000000010000), C64(0x0000000000020000), C64(0x0000000000040000), C64(0x0000000000080000),
		C64(0x0000000000100000), C64(0x0000000000200000), C64(0x0000000000400000), C64(0x0000000000800000),
		C64(0x0000000001000000), C64(0x0000000002000000), C64(0x0000000004000000), C64(0x0000000008000000),
		C64(0x0000000010000000), C64(0x0000000020000000), C64(0x0000000040000000), C64(0x0000000080000000),
		C64(0x0000000100000000), C64(0x0000000200000000), C64(0x0000000400000000), C64(0x0000000800000000),
		C64(0x0000001000000000), C64(0x0000002000000000), C64(0x0000004000000000), C64(0x0000008000000000),
		C64(0x0000010000000000), C64(0x0000020000000000), C64(0x0000040000000000), C64(0x0000080000000000),
		C64(0x0000100000000000), C64(0x0000200000000000), C64(0x0000400000000000), C64(0x0000800000000000),
		C64(0x0001000000000000), C64(0x0002000000000000), C64(0x0004000000000000), C64(0x0008000000000000),
		C64(0x0010000000000000), C64(0x0020000000000000), C64(0x0040000000000000), C64(0x0080000000000000),
		C64(0x0100000000000000), C64(0x0200000000000000), C64(0x0400000000000000), C64(0x0800000000000000),
		C64(0x1000000000000000), C64(0x2000000000000000), C64(0x4000000000000000), C64(0x8000000000000000),
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000),
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000)
	},
	{
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000),
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000),
		C64(0x0000000000000001), C64(0x0000000000000002), C64(0x0000000000000004), C64(0x0000000000000008),
		C64(0x0000000000000010), C64(0x0000000000000020), C64(0x0000000000000040), C64(0x0000000000000080),
		C64(0x0000000000000100), C64(0x0000000000000200), C64(0x0000000000000400), C64(0x0000000000000800),
		C64(0x0000000000001000), C64(0x0000000000002000), C64(0x0000000000004000), C64(0x0000000000008000),
		C64(0x0000000000010000), C64(0x0000000000020000), C64(0x0000000000040000), C64(0x0000000000080000),
		C64(0x0000000000100000), C64(0x0000000000200000), C64(0x0000000000400000), C64(0x0000000000800000),
		C64(0x0000000001000000), C64(0x0000000002000000), C64(0x0000000004000000), C64(0x0000000008000000),
		C64(0x0000000010000000), C64(0x0000000020000000), C64(0x0000000040000000), C64(0x0000000080000000),
		C64(0x0000000100000000), C64(0x0000000200000000), C64(0x0000000400000000), C64(0x0000000800000000),
		C64(0x0000001000000000), C64(0x0000002000000000), C64(0x0000004000000000), C64(0x0000008000000000),
		C64(0x0000010000000000), C64(0x0000020000000000), C64(0x0000040000000000), C64(0x0000080000000000),
		C64(0x0000100000000000), C64(0x0000200000000000), C64(0x0000400000000000), C64(0x0000800000000000),
		C64(0x0001000000000000), C64(0x0002000000000000), C64(0x0004000000000000), C64(0x0008000000000000),
		C64(0x0010000000000000), C64(0x0020000000000000), C64(0x0040000000000000), C64(0x0080000000000000)
	}
};

const U64 Pcaps[2][64]=
{
	{
		C64(0x0000000000000200), C64(0x0000000000000500), C64(0x0000000000000A00), C64(0x0000000000001400),
		C64(0x0000000000002800), C64(0x0000000000005000), C64(0x000000000000A000), C64(0x0000000000004000),
		C64(0x0000000000020000), C64(0x0000000000050000), C64(0x00000000000A0000), C64(0x0000000000140000),
		C64(0x0000000000280000), C64(0x0000000000500000), C64(0x0000000000A00000), C64(0x0000000000400000),
		C64(0x0000000002000000), C64(0x0000000005000000), C64(0x000000000A000000), C64(0x0000000014000000),
		C64(0x0000000028000000), C64(0x0000000050000000), C64(0x00000000A0000000), C64(0x0000000040000000),
		C64(0x0000000200000000), C64(0x0000000500000000), C64(0x0000000A00000000), C64(0x0000001400000000),
		C64(0x0000002800000000), C64(0x0000005000000000), C64(0x000000A000000000), C64(0x0000004000000000),
		C64(0x0000020000000000), C64(0x0000050000000000), C64(0x00000A0000000000), C64(0x0000140000000000),
		C64(0x0000280000000000), C64(0x0000500000000000), C64(0x0000A00000000000), C64(0x0000400000000000),
		C64(0x0002000000000000), C64(0x0005000000000000), C64(0x000A000000000000), C64(0x0014000000000000),
		C64(0x0028000000000000), C64(0x0050000000000000), C64(0x00A0000000000000), C64(0x0040000000000000),
		C64(0x0200000000000000), C64(0x0500000000000000), C64(0x0A00000000000000), C64(0x1400000000000000),
		C64(0x2800000000000000), C64(0x5000000000000000), C64(0xA000000000000000), C64(0x4000000000000000),
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000),
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000)
	},
	{
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000),
		C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000), C64(0x0000000000000000),
		C64(0x0000000000000002), C64(0x0000000000000005), C64(0x000000000000000A), C64(0x0000000000000014),
		C64(0x0000000000000028), C64(0x0000000000000050), C64(0x00000000000000A0), C64(0x0000000000000040),
		C64(0x0000000000000200), C64(0x0000000000000500), C64(0x0000000000000A00), C64(0x0000000000001400),
		C64(0x0000000000002800), C64(0x0000000000005000), C64(0x000000000000A000), C64(0x0000000000004000),
		C64(0x0000000000020000), C64(0x0000000000050000), C64(0x00000000000A0000), C64(0x0000000000140000),
		C64(0x0000000000280000), C64(0x0000000000500000), C64(0x0000000000A00000), C64(0x0000000000400000),
		C64(0x0000000002000000), C64(0x0000000005000000), C64(0x000000000A000000), C64(0x0000000014000000),
		C64(0x0000000028000000), C64(0x0000000050000000), C64(0x00000000A0000000), C64(0x0000000040000000),
		C64(0x0000000200000000), C64(0x0000000500000000), C64(0x0000000A00000000), C64(0x0000001400000000),
		C64(0x0000002800000000), C64(0x0000005000000000), C64(0x000000A000000000), C64(0x0000004000000000),
		C64(0x0000020000000000), C64(0x0000050000000000), C64(0x00000A0000000000), C64(0x0000140000000000),
		C64(0x0000280000000000), C64(0x0000500000000000), C64(0x0000A00000000000), C64(0x0000400000000000),
		C64(0x0002000000000000), C64(0x0005000000000000), C64(0x000A000000000000), C64(0x0014000000000000),
		C64(0x0028000000000000), C64(0x0050000000000000), C64(0x00A0000000000000), C64(0x0040000000000000)
	}
};

const U64 Nmoves[64]=
{
	C64(0x0000000000020400), C64(0x0000000000050800), C64(0x00000000000A1100), C64(0x0000000000142200),
	C64(0x0000000000284400), C64(0x0000000000508800), C64(0x0000000000A01000), C64(0x0000000000402000),
	C64(0x0000000002040004), C64(0x0000000005080008), C64(0x000000000A110011), C64(0x0000000014220022),
	C64(0x0000000028440044), C64(0x0000000050880088), C64(0x00000000A0100010), C64(0x0000000040200020),
	C64(0x0000000204000402), C64(0x0000000508000805), C64(0x0000000A1100110A), C64(0x0000001422002214),
	C64(0x0000002844004428), C64(0x0000005088008850), C64(0x000000A0100010A0), C64(0x0000004020002040),
	C64(0x0000020400040200), C64(0x0000050800080500), C64(0x00000A1100110A00), C64(0x0000142200221400),
	C64(0x0000284400442800), C64(0x0000508800885000), C64(0x0000A0100010A000), C64(0x0000402000204000),
	C64(0x0002040004020000), C64(0x0005080008050000), C64(0x000A1100110A0000), C64(0x0014220022140000),
	C64(0x0028440044280000), C64(0x0050880088500000), C64(0x00A0100010A00000), C64(0x0040200020400000),
	C64(0x0204000402000000), C64(0x0508000805000000), C64(0x0A1100110A000000), C64(0x1422002214000000),
	C64(0x2844004428000000), C64(0x5088008850000000), C64(0xA0100010A0000000), C64(0x4020002040000000),
	C64(0x0400040200000000), C64(0x0800080500000000), C64(0x1100110A00000000), C64(0x2200221400000000),
	C64(0x4400442800000000), C64(0x8800885000000000), C64(0x100010A000000000), C64(0x2000204000000000),
	C64(0x0004020000000000), C64(0x0008050000000000), C64(0x00110A0000000000), C64(0x0022140000000000),
	C64(0x0044280000000000), C64(0x0088500000000000), C64(0x0010A00000000000), C64(0x0020400000000000)
};

const U64 Kmoves[64]=
{
	C64(0x0000000000000302), C64(0x0000000000000705), C64(0x0000000000000E0A), C64(0x0000000000001C14),
	C64(0x0000000000003828), C64(0x0000000000007050), C64(0x000000000000E0A0), C64(0x000000000000C040),
	C64(0x0000000000030203), C64(0x0000000000070507), C64(0x00000000000E0A0E), C64(0x00000000001C141C),
	C64(0x0000000000382838), C64(0x0000000000705070), C64(0x0000000000E0A0E0), C64(0x0000000000C040C0),
	C64(0x0000000003020300), C64(0x0000000007050700), C64(0x000000000E0A0E00), C64(0x000000001C141C00),
	C64(0x0000000038283800), C64(0x0000000070507000), C64(0x00000000E0A0E000), C64(0x00000000C040C000),
	C64(0x0000000302030000), C64(0x0000000705070000), C64(0x0000000E0A0E0000), C64(0x0000001C141C0000),
	C64(0x0000003828380000), C64(0x0000007050700000), C64(0x000000E0A0E00000), C64(0x000000C040C00000),
	C64(0x0000030203000000), C64(0x0000070507000000), C64(0x00000E0A0E000000), C64(0x00001C141C000000),
	C64(0x0000382838000000), C64(0x0000705070000000), C64(0x0000E0A0E0000000), C64(0x0000C040C0000000),
	C64(0x0003020300000000), C64(0x0007050700000000), C64(0x000E0A0E00000000), C64(0x001C141C00000000),
	C64(0x0038283800000000), C64(0x0070507000000000), C64(0x00E0A0E000000000), C64(0x00C040C000000000),
	C64(0x0302030000000000), C64(0x0705070000000000), C64(0x0E0A0E0000000000), C64(0x1C141C0000000000),
	C64(0x3828380000000000), C64(0x7050700000000000), C64(0xE0A0E00000000000), C64(0xC040C00000000000),
	C64(0x0203000000000000), C64(0x0507000000000000), C64(0x0A0E000000000000), C64(0x141C000000000000),
	C64(0x2838000000000000), C64(0x5070000000000000), C64(0xA0E0000000000000), C64(0x40C0000000000000)
};

const U64 BmovesNoOcc[64]=
{
	C64(0x8040201008040200),C64(0x0080402010080500),C64(0x0000804020110A00),C64(0x0000008041221400),
	C64(0x0000000182442800),C64(0x0000010204885000),C64(0x000102040810A000),C64(0x0102040810204000),
	C64(0x4020100804020002),C64(0x8040201008050005),C64(0x00804020110A000A),C64(0x0000804122140014),
	C64(0x0000018244280028),C64(0x0001020488500050),C64(0x0102040810A000A0),C64(0x0204081020400040),
	C64(0x2010080402000204),C64(0x4020100805000508),C64(0x804020110A000A11),C64(0x0080412214001422),
	C64(0x0001824428002844),C64(0x0102048850005088),C64(0x02040810A000A010),C64(0x0408102040004020),
	C64(0x1008040200020408),C64(0x2010080500050810),C64(0x4020110A000A1120),C64(0x8041221400142241),
	C64(0x0182442800284482),C64(0x0204885000508804),C64(0x040810A000A01008),C64(0x0810204000402010),
	C64(0x0804020002040810),C64(0x1008050005081020),C64(0x20110A000A112040),C64(0x4122140014224180),
	C64(0x8244280028448201),C64(0x0488500050880402),C64(0x0810A000A0100804),C64(0x1020400040201008),
	C64(0x0402000204081020),C64(0x0805000508102040),C64(0x110A000A11204080),C64(0x2214001422418000),
	C64(0x4428002844820100),C64(0x8850005088040201),C64(0x10A000A010080402),C64(0x2040004020100804),
	C64(0x0200020408102040),C64(0x0500050810204080),C64(0x0A000A1120408000),C64(0x1400142241800000),
	C64(0x2800284482010000),C64(0x5000508804020100),C64(0xA000A01008040201),C64(0x4000402010080402),
	C64(0x0002040810204080),C64(0x0005081020408000),C64(0x000A112040800000),C64(0x0014224180000000),
	C64(0x0028448201000000),C64(0x0050880402010000),C64(0x00A0100804020100),C64(0x0040201008040201)
};

const U64 RmovesNoOcc[64]=
{
	C64(0x01010101010101FE),C64(0x02020202020202FD),C64(0x04040404040404FB),C64(0x08080808080808F7),
	C64(0x10101010101010EF),C64(0x20202020202020DF),C64(0x40404040404040BF),C64(0x808080808080807F),
	C64(0x010101010101FE01),C64(0x020202020202FD02),C64(0x040404040404FB04),C64(0x080808080808F708),
	C64(0x101010101010EF10),C64(0x202020202020DF20),C64(0x404040404040BF40),C64(0x8080808080807F80),
	C64(0x0101010101FE0101),C64(0x0202020202FD0202),C64(0x0404040404FB0404),C64(0x0808080808F70808),
	C64(0x1010101010EF1010),C64(0x2020202020DF2020),C64(0x4040404040BF4040),C64(0x80808080807F8080),
	C64(0x01010101FE010101),C64(0x02020202FD020202),C64(0x04040404FB040404),C64(0x08080808F7080808),
	C64(0x10101010EF101010),C64(0x20202020DF202020),C64(0x40404040BF404040),C64(0x808080807F808080),
	C64(0x010101FE01010101),C64(0x020202FD02020202),C64(0x040404FB04040404),C64(0x080808F708080808),
	C64(0x101010EF10101010),C64(0x202020DF20202020),C64(0x404040BF40404040),C64(0x8080807F80808080),
	C64(0x0101FE0101010101),C64(0x0202FD0202020202),C64(0x0404FB0404040404),C64(0x0808F70808080808),
	C64(0x1010EF1010101010),C64(0x2020DF2020202020),C64(0x4040BF4040404040),C64(0x80807F8080808080),
	C64(0x01FE010101010101),C64(0x02FD020202020202),C64(0x04FB040404040404),C64(0x08F7080808080808),
	C64(0x10EF101010101010),C64(0x20DF202020202020),C64(0x40BF404040404040),C64(0x807F808080808080),
	C64(0xFE01010101010101),C64(0xFD02020202020202),C64(0xFB04040404040404),C64(0xF708080808080808),
	C64(0xEF10101010101010),C64(0xDF20202020202020),C64(0xBF40404040404040),C64(0x7F80808080808080)
};

U64 inBetween[64][64];
U64 lineOf[64][64];

//Fills of Bishop, Rook, and Knight moves for moves around the king
const U64 KNFill[64]=
{
        C64(0x00000000070D0B0E), C64(0x000000000F1F171D), C64(0x000000001F3F2E3B), C64(0x000000003E7F5D77),
        C64(0x000000007CFEBAEE), C64(0x00000000F8FC74DC), C64(0x00000000F0F8E8B8), C64(0x00000000E0B0D070),
        C64(0x000000070D0F0E0F), C64(0x0000000F1F1F1D1F), C64(0x0000001F3F3F3B3F), C64(0x0000003E7F7F777F),
        C64(0x0000007CFEFEEEFE), C64(0x000000F8FCFCDCFC), C64(0x000000F0F8F8B8F8), C64(0x000000E0B0F070F0),
        C64(0x0000070D0F0E0F0D), C64(0x00000F1F1F1D1F1F), C64(0x00001F3F3F3B3F3F), C64(0x00003E7F7F777F7F),
        C64(0x00007CFEFEEEFEFE), C64(0x0000F8FCFCDCFCFC), C64(0x0000F0F8F8B8F8F8), C64(0x0000E0B0F070F0B0),
        C64(0x00070D0F0E0F0D07), C64(0x000F1F1F1D1F1F0F), C64(0x001F3F3F3B3F3F1F), C64(0x003E7F7F777F7F3E),
        C64(0x007CFEFEEEFEFE7C), C64(0x00F8FCFCDCFCFCF8), C64(0x00F0F8F8B8F8F8F0), C64(0x00E0B0F070F0B0E0),
        C64(0x070D0F0E0F0D0700), C64(0x0F1F1F1D1F1F0F00), C64(0x1F3F3F3B3F3F1F00), C64(0x3E7F7F777F7F3E00),
        C64(0x7CFEFEEEFEFE7C00), C64(0xF8FCFCDCFCFCF800), C64(0xF0F8F8B8F8F8F000), C64(0xE0B0F070F0B0E000),
        C64(0x0D0F0E0F0D070000), C64(0x1F1F1D1F1F0F0000), C64(0x3F3F3B3F3F1F0000), C64(0x7F7F777F7F3E0000),
        C64(0xFEFEEEFEFE7C0000), C64(0xFCFCDCFCFCF80000), C64(0xF8F8B8F8F8F00000), C64(0xB0F070F0B0E00000),
        C64(0x0F0E0F0D07000000), C64(0x1F1D1F1F0F000000), C64(0x3F3B3F3F1F000000), C64(0x7F777F7F3E000000),
        C64(0xFEEEFEFE7C000000), C64(0xFCDCFCFCF8000000), C64(0xF8B8F8F8F0000000), C64(0xF070F0B0E0000000),
        C64(0x0E0B0D0700000000), C64(0x1D171F0F00000000), C64(0x3B2E3F1F00000000), C64(0x775D7F3E00000000),
        C64(0xEEBAFE7C00000000), C64(0xDC74FCF800000000), C64(0xB8E8F8F000000000), C64(0x70D0B0E000000000)
};
const U64 KBFill[64]=
{
        C64(0xC0E070381C0F0707), C64(0xC0E0F0783D1F0F0F), C64(0x80C0E0F17B3F1F1F), C64(0x0080C1E3F77F3E3E),
        C64(0x000183C7EFFE7C7C), C64(0x0103078FDEFCF8F8), C64(0x03070F1EBCF8F0F0), C64(0x03070E1C38F0E0E0),
        C64(0xE0F0783C1F0F070F), C64(0xE0F0F87D3F1F0F1F), C64(0xC0E0F1FB7F3F1F3F), C64(0x80C1E3F7FF7F3E7F),
        C64(0x0183C7EFFFFE7CFE), C64(0x03078FDFFEFCF8FC), C64(0x070F1FBEFCF8F0F8), C64(0x070F1E3CF8F0E0F0),
        C64(0xF0783C1F0F070F1F), C64(0xF0F87D3F1F0F1F3F), C64(0xE0F1FB7F3F1F3F7F), C64(0xC1E3F7FF7F3E7FFF),
        C64(0x83C7EFFFFE7CFEFF), C64(0x078FDFFEFCF8FCFE), C64(0x0F1FBEFCF8F0F8FC), C64(0x0F1E3CF8F0E0F0F8),
        C64(0x783C1F0F070F1F3C), C64(0xF87D3F1F0F1F3F7D), C64(0xF1FB7F3F1F3F7FFB), C64(0xE3F7FF7F3E7FFFF7),
        C64(0xC7EFFFFE7CFEFFEF), C64(0x8FDFFEFCF8FCFEDF), C64(0x1FBEFCF8F0F8FCBE), C64(0x1E3CF8F0E0F0F83C),
        C64(0x3C1F0F070F1F3C78), C64(0x7D3F1F0F1F3F7DF8), C64(0xFB7F3F1F3F7FFBF1), C64(0xF7FF7F3E7FFFF7E3),
        C64(0xEFFFFE7CFEFFEFC7), C64(0xDFFEFCF8FCFEDF8F), C64(0xBEFCF8F0F8FCBE1F), C64(0x3CF8F0E0F0F83C1E),
        C64(0x1F0F070F1F3C78F0), C64(0x3F1F0F1F3F7DF8F0), C64(0x7F3F1F3F7FFBF1E0), C64(0xFF7F3E7FFFF7E3C1),
        C64(0xFFFE7CFEFFEFC783), C64(0xFEFCF8FCFEDF8F07), C64(0xFCF8F0F8FCBE1F0F), C64(0xF8F0E0F0F83C1E0F),
        C64(0x0F070F1F3C78F0E0), C64(0x1F0F1F3F7DF8F0E0), C64(0x3F1F3F7FFBF1E0C0), C64(0x7F3E7FFFF7E3C180),
        C64(0xFE7CFEFFEFC78301), C64(0xFCF8FCFEDF8F0703), C64(0xF8F0F8FCBE1F0F07), C64(0xF0E0F0F83C1E0F07),
        C64(0x07070F1C3870E0C0), C64(0x0F0F1F3D78F0E0C0), C64(0x1F1F3F7BF1E0C080), C64(0x3E3E7FF7E3C18000),
        C64(0x7C7CFEEFC7830100), C64(0xF8F8FCDE8F070301), C64(0xF0F0F8BC1E0F0703), C64(0xE0E0F0381C0E0703)
};
const U64 KRFill[64]=
{
        C64(0x030303030303FFFF), C64(0x070707070707FFFF), C64(0x0E0E0E0E0E0EFFFF), C64(0x1C1C1C1C1C1CFFFF),
        C64(0x383838383838FFFF), C64(0x707070707070FFFF), C64(0xE0E0E0E0E0E0FFFF), C64(0xC0C0C0C0C0C0FFFF),
        C64(0x0303030303FFFFFF), C64(0x0707070707FFFFFF), C64(0x0E0E0E0E0EFFFFFF), C64(0x1C1C1C1C1CFFFFFF),
        C64(0x3838383838FFFFFF), C64(0x7070707070FFFFFF), C64(0xE0E0E0E0E0FFFFFF), C64(0xC0C0C0C0C0FFFFFF),
        C64(0x03030303FFFFFF03), C64(0x07070707FFFFFF07), C64(0x0E0E0E0EFFFFFF0E), C64(0x1C1C1C1CFFFFFF1C),
        C64(0x38383838FFFFFF38), C64(0x70707070FFFFFF70), C64(0xE0E0E0E0FFFFFFE0), C64(0xC0C0C0C0FFFFFFC0),
        C64(0x030303FFFFFF0303), C64(0x070707FFFFFF0707), C64(0x0E0E0EFFFFFF0E0E), C64(0x1C1C1CFFFFFF1C1C),
        C64(0x383838FFFFFF3838), C64(0x707070FFFFFF7070), C64(0xE0E0E0FFFFFFE0E0), C64(0xC0C0C0FFFFFFC0C0),
        C64(0x0303FFFFFF030303), C64(0x0707FFFFFF070707), C64(0x0E0EFFFFFF0E0E0E), C64(0x1C1CFFFFFF1C1C1C),
        C64(0x3838FFFFFF383838), C64(0x7070FFFFFF707070), C64(0xE0E0FFFFFFE0E0E0), C64(0xC0C0FFFFFFC0C0C0),
        C64(0x03FFFFFF03030303), C64(0x07FFFFFF07070707), C64(0x0EFFFFFF0E0E0E0E), C64(0x1CFFFFFF1C1C1C1C),
        C64(0x38FFFFFF38383838), C64(0x70FFFFFF70707070), C64(0xE0FFFFFFE0E0E0E0), C64(0xC0FFFFFFC0C0C0C0),
        C64(0xFFFFFF0303030303), C64(0xFFFFFF0707070707), C64(0xFFFFFF0E0E0E0E0E), C64(0xFFFFFF1C1C1C1C1C),
        C64(0xFFFFFF3838383838), C64(0xFFFFFF7070707070), C64(0xFFFFFFE0E0E0E0E0), C64(0xFFFFFFC0C0C0C0C0),
        C64(0xFFFF030303030303), C64(0xFFFF070707070707), C64(0xFFFF0E0E0E0E0E0E), C64(0xFFFF1C1C1C1C1C1C),
        C64(0xFFFF383838383838), C64(0xFFFF707070707070), C64(0xFFFFE0E0E0E0E0E0), C64(0xFFFFC0C0C0C0C0C0)
};
const U64 KQFill[64]=
{
        C64(0xC3E3733B1F0FFFFF), C64(0xC7E7F77F3F1FFFFF), C64(0x8ECEEEFF7F3FFFFF), C64(0x1C9CDDFFFF7FFFFF),
        C64(0x3839BBFFFFFEFFFF), C64(0x717377FFFEFCFFFF), C64(0xE3E7EFFEFCF8FFFF), C64(0xC3C7CEDCF8F0FFFF),
        C64(0xE3F37B3F1FFFFFFF), C64(0xE7F7FF7F3FFFFFFF), C64(0xCEEEFFFF7FFFFFFF), C64(0x9CDDFFFFFFFFFFFF),
        C64(0x39BBFFFFFFFFFFFF), C64(0x7377FFFFFEFFFFFF), C64(0xE7EFFFFEFCFFFFFF), C64(0xC7CFDEFCF8FFFFFF),
        C64(0xF37B3F1FFFFFFF1F), C64(0xF7FF7F3FFFFFFF3F), C64(0xEEFFFF7FFFFFFF7F), C64(0xDDFFFFFFFFFFFFFF),
        C64(0xBBFFFFFFFFFFFFFF), C64(0x77FFFFFEFFFFFFFE), C64(0xEFFFFEFCFFFFFFFC), C64(0xCFDEFCF8FFFFFFF8),
        C64(0x7B3F1FFFFFFF1F3F), C64(0xFF7F3FFFFFFF3F7F), C64(0xFFFF7FFFFFFF7FFF), C64(0xFFFFFFFFFFFFFFFF),
        C64(0xFFFFFFFFFFFFFFFF), C64(0xFFFFFEFFFFFFFEFF), C64(0xFFFEFCFFFFFFFCFE), C64(0xDEFCF8FFFFFFF8FC),
        C64(0x3F1FFFFFFF1F3F7B), C64(0x7F3FFFFFFF3F7FFF), C64(0xFF7FFFFFFF7FFFFF), C64(0xFFFFFFFFFFFFFFFF),
        C64(0xFFFFFFFFFFFFFFFF), C64(0xFFFEFFFFFFFEFFFF), C64(0xFEFCFFFFFFFCFEFF), C64(0xFCF8FFFFFFF8FCDE),
        C64(0x1FFFFFFF1F3F7BF3), C64(0x3FFFFFFF3F7FFFF7), C64(0x7FFFFFFF7FFFFFEE), C64(0xFFFFFFFFFFFFFFDD),
        C64(0xFFFFFFFFFFFFFFBB), C64(0xFEFFFFFFFEFFFF77), C64(0xFCFFFFFFFCFEFFEF), C64(0xF8FFFFFFF8FCDECF),
        C64(0xFFFFFF1F3F7BF3E3), C64(0xFFFFFF3F7FFFF7E7), C64(0xFFFFFF7FFFFFEECE), C64(0xFFFFFFFFFFFFDD9C),
        C64(0xFFFFFFFFFFFFBB39), C64(0xFFFFFFFEFFFF7773), C64(0xFFFFFFFCFEFFEFE7), C64(0xFFFFFFF8FCDECFC7),
        C64(0xFFFF0F1F3B73E3C3), C64(0xFFFF1F3F7FF7E7C7), C64(0xFFFF3F7FFFEECE8E), C64(0xFFFF7FFFFFDD9C1C),
        C64(0xFFFFFEFFFFBB3938), C64(0xFFFFFCFEFF777371), C64(0xFFFFF8FCFEEFE7E3), C64(0xFFFFF0F8DCCEC7C3)
};


#define removeLSB(X) (X&=X-1)
#define toBit(X) toBitDB[X]
#define LastOne(X) (toIndex(MSB(X)))
#define FirstOne(X) (toIndex(LSB(X)))
#define toIndex(X) toIndexDB[(X)*C64(0x07EDD5E59A4E28C2)>>58]


#define LSB(X) ((X)&-(X))
//#define LSB(X) ((X)&(~(X)+1))

const U64 toBitDB[64]=
{
	C64(1)<< 0, C64(1)<< 1, C64(1)<< 2, C64(1)<< 3,
	C64(1)<< 4, C64(1)<< 5, C64(1)<< 6, C64(1)<< 7,
	C64(1)<< 8, C64(1)<< 9, C64(1)<<10, C64(1)<<11,
	C64(1)<<12, C64(1)<<13, C64(1)<<14, C64(1)<<15,
	C64(1)<<16, C64(1)<<17, C64(1)<<18, C64(1)<<19,
	C64(1)<<20, C64(1)<<21, C64(1)<<22, C64(1)<<23,
	C64(1)<<24, C64(1)<<25, C64(1)<<26, C64(1)<<27,
	C64(1)<<28, C64(1)<<29, C64(1)<<30, C64(1)<<31,
	C64(1)<<32, C64(1)<<33, C64(1)<<34, C64(1)<<35,
	C64(1)<<36, C64(1)<<37, C64(1)<<38, C64(1)<<39,
	C64(1)<<40, C64(1)<<41, C64(1)<<42, C64(1)<<43,
	C64(1)<<44, C64(1)<<45, C64(1)<<46, C64(1)<<47,
	C64(1)<<48, C64(1)<<49, C64(1)<<50, C64(1)<<51,
	C64(1)<<52, C64(1)<<53, C64(1)<<54, C64(1)<<55,
	C64(1)<<56, C64(1)<<57, C64(1)<<58, C64(1)<<59,
	C64(1)<<60, C64(1)<<61, C64(1)<<62, C64(1)<<63
};

const int toIndexDB[64]=
{
	63,  0, 58,  1, 59, 47, 53,  2,
	60, 39, 48, 27, 54, 33, 42,  3,
	61, 51, 37, 40, 49, 18, 28, 20,
	55, 30, 34, 11, 43, 14, 22,  4,
	62, 57, 46, 52, 38, 26, 32, 41,
	50, 36, 17, 19, 29, 10, 13, 21,
	56, 45, 25, 31, 35, 16,  9, 12,
	44, 24, 15,  8, 23,  7,  6,  5
};


static inline U64 MSB(U64 x)
{
	x|=x>>1;
	x|=x>>2;
	x|=x>>4;
	x|=x>>8;
	x|=x>>16;
	x|=x>>32;
	x=(x>>1)+1;
	return x;
}

static inline int iterative_popcount(U64 b)
{
    int n;
    for (n=0 ; b ; n++, removeLSB(b));
    return n;
}

//Hamming Weights - from Wikipedia
#define m1_64  C64(0x5555555555555555)
#define m2_64  C64(0x3333333333333333)
#define m4_64  C64(0x0F0F0F0F0F0F0F0F)
#define m8_64  C64(0x00FF00FF00FF00FF)
#define m16_64 C64(0x0000FFFF0000FFFF)
#define hFF_64 C64(0xFFFFFFFFFFFFFFFF)
#define h01_64 C64(0x0101010101010101)

//This uses fewer arithmetic operations than any other known
//implementation on machines with slow multiplication.
//It uses 17 arithmetic operations.
static inline int slowmul_popcount(U64 x)
{
    x -= (x >> 1) & m1_64;             //put count of each 2 bits into those 2 bits
    x = (x & m2_64) + ((x >> 2) & m2_64); //put count of each 4 bits into those 4 bits
    x = (x + (x >> 4)) & m4_64;        //put count of each 8 bits into those 8 bits
    x += x >>  8;  //put count of each 16 bits into their lowest 8 bits
    x += x >> 16;  //put count of each 32 bits into their lowest 8 bits
    x += x >> 32;  //put count of each 64 bits into their lowest 8 bits
    return (int)(x & 0xff);
}

//This uses fewer arithmetic operations than any other known
//implementation on machines with fast multiplication.
//It uses 12 arithmetic operations, one of which is a multiply.
static inline int fastmul_popcount(U64 x)
{
    x -= (x >> 1) & m1_64;             //put count of each 2 bits into those 2 bits
    x = (x & m2_64) + ((x >> 2) & m2_64); //put count of each 4 bits into those 4 bits
    x = (x + (x >> 4)) & m4_64;        //put count of each 8 bits into those 8 bits
    return (int)((x * h01_64)>>56);  //returns left 8 bits of x + (x<<8) + (x<<16) + (x<<24) + ...
}

//returns a bitboard with all bits above b filled up (discluding b)
static inline U64 fillUp(U64 b)
{
	b|=b<<8;
	b|=b<<16;
	return (b|(b<<32))<<8;
}

//returns a bitboard with all bits below b filled down (discluding b)
static inline U64 fillDown(U64 b)
{
	b|=b>>8;
	b|=b>>16;
	return (b|(b>>32))>>8;
}

//returns a bitboard with all bits above b filled up (including b)
static inline U64 fillUp2(U64 b)
{
	b|=b<<8;
	b|=b<<16;
	return b|(b<<32);
}

//returns a bitboard with all bits below b filled down (including b)
static inline U64 fillDown2(U64 b)
{
	b|=b>>8;
	b|=b>>16;
	return b|(b>>32);
}

//Gerd-Isenberg's Carry Propogate Fill
static inline U64 fillRight(U64 pieces, U64 occ)
{
	const U64 H  =  C64(0x8080808080808080);
	U64 piecesNH = pieces&~H;
	U64 inclRook =  pieces | H | occ;
	U64 exclRook = (piecesNH) ^ inclRook;
	U64 attacks  = (exclRook - piecesNH) ^ inclRook;
	return attacks|pieces;
}

//Kogge-Stone Fills from Stefan Wescott
/**
The routine FillUpOccluded() smears the set bits of bitboard g upwards, but only
along set bits of p; a reset bit in p is enough to halt a smear.
*/
static inline U64 fillUpOccluded(U64 g, U64 p)
{
	g |= p & (g << 8);
	p &=     (p << 8);
	g |= p & (g << 16);
	p &=     (p << 16);
	return g |= p & (g << 32);
}

static inline U64 fillDownOccluded(U64 g, U64 p)
{
	g |= p & (g >> 8);
	p &=     (p >> 8);
	g |= p & (g >> 16);
	p &=     (p >> 16);
	return g |= p & (g >> 32);
}

static inline U64 fillRightOccluded(U64 g, U64 p)
{
	p &= C64(0xFEFEFEFEFEFEFEFE);
	g |= p & (g << 1);
	p &=     (p << 1);
	g |= p & (g << 2);
	p &=     (p << 2);
	return g |= p & (g << 4);
}

static inline U64 fillLeftOccluded(U64 g, U64 p)
{
	p &= C64(0x7F7F7F7F7F7F7F7F);
	g |= p & (g >> 1);
	p &=     (p >> 1);
	g |= p & (g >> 2);
	p &=     (p >> 2);
	return g |= p & (g >> 4);
}

static inline U64 fillUpRightOccluded(U64 g, U64 p)
{
	p &= C64(0xFEFEFEFEFEFEFEFE);
	g |= p & (g <<  9);
	p &=     (p <<  9);
	g |= p & (g << 18);
	p &=     (p << 18);
	return g |= p & (g << 36);
}

static inline U64 fillUpLeftOccluded(U64 g, U64 p)
{
	p &= C64(0x7F7F7F7F7F7F7F7F);
	g |= p & (g <<  7);
	p &=     (p <<  7);
	g |= p & (g << 14);
	p &=     (p << 14);
	return g |= p & (g << 28);
}

static inline U64 fillDownRightOccluded(U64 g, U64 p)
{
	p &= C64(0xFEFEFEFEFEFEFEFE);
	g |= p & (g >>  7);
	p &=     (p >>  7);
	g |= p & (g >> 14);
	p &=     (p >> 14);
	return g |= p & (g >> 28);
}

static inline U64 fillDownLeftOccluded(U64 g, U64 p)
{
	p &= C64(0x7F7F7F7F7F7F7F7F);
	g |= p & (g >>  9);
	p &=     (p >>  9);
	g |= p & (g >> 18);
	p &=     (p >> 18);
	return g |= p & (g >> 36);
}

//For convienence during pawn eval
static inline U64 fillUpOcc(U64 pieces, U64 occ)
{
	occ=~(occ&~pieces);
	return fillUpOccluded(pieces,occ<<8);
}

//For convienence during pawn eval
static inline U64 fillDownOcc(U64 pieces, U64 occ)
{
	occ=~(occ&~pieces);
	return fillDownOccluded(pieces,occ>>8);
}

#define GetBitAndClear(bb, ret) U64 tmpgbac=(bb&-bb); \
		bb^=tmpgbac; \
		ret=toIndex(tmpgbac)
#define GetBitAndClearOther(bb, clearbb, ret) U64 tmpgbac=(bb&-bb); \
		clearbb^=tmpgbac; \
		ret=toIndex(tmpgbac)


// magicmoves

//For rooks

//original 12 bit keys
//C64(0x0000002040810402) - H8 12 bit
//C64(0x0000102040800101) - A8 12 bit
//C64(0x0000102040008101) - B8 11 bit
//C64(0x0000081020004101) - C8 11 bit

//Adapted Grant Osborne's keys
//C64(0x0001FFFAABFAD1A2) - H8 11 bit
//C64(0x00FFFCDDFCED714A) - A8 11 bit
//C64(0x007FFCDDFCED714A) - B8 10 bit
//C64(0x003FFFCDFFD88096) - C8 10 bit

const unsigned int magicmoves_r_shift[64]=
{
	52, 53, 53, 53, 53, 53, 53, 52,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 53, 53, 53, 53, 53
};

const U64 magicmoves_r_magics[64]=
{
	C64(0x0080001020400080), C64(0x0040001000200040), C64(0x0080081000200080), C64(0x0080040800100080),
	C64(0x0080020400080080), C64(0x0080010200040080), C64(0x0080008001000200), C64(0x0080002040800100),
	C64(0x0000800020400080), C64(0x0000400020005000), C64(0x0000801000200080), C64(0x0000800800100080),
	C64(0x0000800400080080), C64(0x0000800200040080), C64(0x0000800100020080), C64(0x0000800040800100),
	C64(0x0000208000400080), C64(0x0000404000201000), C64(0x0000808010002000), C64(0x0000808008001000),
	C64(0x0000808004000800), C64(0x0000808002000400), C64(0x0000010100020004), C64(0x0000020000408104),
	C64(0x0000208080004000), C64(0x0000200040005000), C64(0x0000100080200080), C64(0x0000080080100080),
	C64(0x0000040080080080), C64(0x0000020080040080), C64(0x0000010080800200), C64(0x0000800080004100),
	C64(0x0000204000800080), C64(0x0000200040401000), C64(0x0000100080802000), C64(0x0000080080801000),
	C64(0x0000040080800800), C64(0x0000020080800400), C64(0x0000020001010004), C64(0x0000800040800100),
	C64(0x0000204000808000), C64(0x0000200040008080), C64(0x0000100020008080), C64(0x0000080010008080),
	C64(0x0000040008008080), C64(0x0000020004008080), C64(0x0000010002008080), C64(0x0000004081020004),
	C64(0x0000204000800080), C64(0x0000200040008080), C64(0x0000100020008080), C64(0x0000080010008080),
	C64(0x0000040008008080), C64(0x0000020004008080), C64(0x0000800100020080), C64(0x0000800041000080),
	C64(0x00FFFCDDFCED714A), C64(0x007FFCDDFCED714A), C64(0x003FFFCDFFD88096), C64(0x0000040810002101),
	C64(0x0001000204080011), C64(0x0001000204000801), C64(0x0001000082000401), C64(0x0001FFFAABFAD1A2)
};
const U64 magicmoves_r_mask[64]=
{
	C64(0x000101010101017E), C64(0x000202020202027C), C64(0x000404040404047A), C64(0x0008080808080876),
	C64(0x001010101010106E), C64(0x002020202020205E), C64(0x004040404040403E), C64(0x008080808080807E),
	C64(0x0001010101017E00), C64(0x0002020202027C00), C64(0x0004040404047A00), C64(0x0008080808087600),
	C64(0x0010101010106E00), C64(0x0020202020205E00), C64(0x0040404040403E00), C64(0x0080808080807E00),
	C64(0x00010101017E0100), C64(0x00020202027C0200), C64(0x00040404047A0400), C64(0x0008080808760800),
	C64(0x00101010106E1000), C64(0x00202020205E2000), C64(0x00404040403E4000), C64(0x00808080807E8000),
	C64(0x000101017E010100), C64(0x000202027C020200), C64(0x000404047A040400), C64(0x0008080876080800),
	C64(0x001010106E101000), C64(0x002020205E202000), C64(0x004040403E404000), C64(0x008080807E808000),
	C64(0x0001017E01010100), C64(0x0002027C02020200), C64(0x0004047A04040400), C64(0x0008087608080800),
	C64(0x0010106E10101000), C64(0x0020205E20202000), C64(0x0040403E40404000), C64(0x0080807E80808000),
	C64(0x00017E0101010100), C64(0x00027C0202020200), C64(0x00047A0404040400), C64(0x0008760808080800),
	C64(0x00106E1010101000), C64(0x00205E2020202000), C64(0x00403E4040404000), C64(0x00807E8080808000),
	C64(0x007E010101010100), C64(0x007C020202020200), C64(0x007A040404040400), C64(0x0076080808080800),
	C64(0x006E101010101000), C64(0x005E202020202000), C64(0x003E404040404000), C64(0x007E808080808000),
	C64(0x7E01010101010100), C64(0x7C02020202020200), C64(0x7A04040404040400), C64(0x7608080808080800),
	C64(0x6E10101010101000), C64(0x5E20202020202000), C64(0x3E40404040404000), C64(0x7E80808080808000)
};

//my original tables for bishops
const unsigned int magicmoves_b_shift[64]=
{
	58, 59, 59, 59, 59, 59, 59, 58,
	59, 59, 59, 59, 59, 59, 59, 59,
	59, 59, 57, 57, 57, 57, 59, 59,
	59, 59, 57, 55, 55, 57, 59, 59,
	59, 59, 57, 55, 55, 57, 59, 59,
	59, 59, 57, 57, 57, 57, 59, 59,
	59, 59, 59, 59, 59, 59, 59, 59,
	58, 59, 59, 59, 59, 59, 59, 58
};

const U64 magicmoves_b_magics[64]=
{
	C64(0x0002020202020200), C64(0x0002020202020000), C64(0x0004010202000000), C64(0x0004040080000000),
	C64(0x0001104000000000), C64(0x0000821040000000), C64(0x0000410410400000), C64(0x0000104104104000),
	C64(0x0000040404040400), C64(0x0000020202020200), C64(0x0000040102020000), C64(0x0000040400800000),
	C64(0x0000011040000000), C64(0x0000008210400000), C64(0x0000004104104000), C64(0x0000002082082000),
	C64(0x0004000808080800), C64(0x0002000404040400), C64(0x0001000202020200), C64(0x0000800802004000),
	C64(0x0000800400A00000), C64(0x0000200100884000), C64(0x0000400082082000), C64(0x0000200041041000),
	C64(0x0002080010101000), C64(0x0001040008080800), C64(0x0000208004010400), C64(0x0000404004010200),
	C64(0x0000840000802000), C64(0x0000404002011000), C64(0x0000808001041000), C64(0x0000404000820800),
	C64(0x0001041000202000), C64(0x0000820800101000), C64(0x0000104400080800), C64(0x0000020080080080),
	C64(0x0000404040040100), C64(0x0000808100020100), C64(0x0001010100020800), C64(0x0000808080010400),
	C64(0x0000820820004000), C64(0x0000410410002000), C64(0x0000082088001000), C64(0x0000002011000800),
	C64(0x0000080100400400), C64(0x0001010101000200), C64(0x0002020202000400), C64(0x0001010101000200),
	C64(0x0000410410400000), C64(0x0000208208200000), C64(0x0000002084100000), C64(0x0000000020880000),
	C64(0x0000001002020000), C64(0x0000040408020000), C64(0x0004040404040000), C64(0x0002020202020000),
	C64(0x0000104104104000), C64(0x0000002082082000), C64(0x0000000020841000), C64(0x0000000000208800),
	C64(0x0000000010020200), C64(0x0000000404080200), C64(0x0000040404040400), C64(0x0002020202020200)
};


const U64 magicmoves_b_mask[64]=
{
	C64(0x0040201008040200), C64(0x0000402010080400), C64(0x0000004020100A00), C64(0x0000000040221400),
	C64(0x0000000002442800), C64(0x0000000204085000), C64(0x0000020408102000), C64(0x0002040810204000),
	C64(0x0020100804020000), C64(0x0040201008040000), C64(0x00004020100A0000), C64(0x0000004022140000),
	C64(0x0000000244280000), C64(0x0000020408500000), C64(0x0002040810200000), C64(0x0004081020400000),
	C64(0x0010080402000200), C64(0x0020100804000400), C64(0x004020100A000A00), C64(0x0000402214001400),
	C64(0x0000024428002800), C64(0x0002040850005000), C64(0x0004081020002000), C64(0x0008102040004000),
	C64(0x0008040200020400), C64(0x0010080400040800), C64(0x0020100A000A1000), C64(0x0040221400142200),
	C64(0x0002442800284400), C64(0x0004085000500800), C64(0x0008102000201000), C64(0x0010204000402000),
	C64(0x0004020002040800), C64(0x0008040004081000), C64(0x00100A000A102000), C64(0x0022140014224000),
	C64(0x0044280028440200), C64(0x0008500050080400), C64(0x0010200020100800), C64(0x0020400040201000),
	C64(0x0002000204081000), C64(0x0004000408102000), C64(0x000A000A10204000), C64(0x0014001422400000),
	C64(0x0028002844020000), C64(0x0050005008040200), C64(0x0020002010080400), C64(0x0040004020100800),
	C64(0x0000020408102000), C64(0x0000040810204000), C64(0x00000A1020400000), C64(0x0000142240000000),
	C64(0x0000284402000000), C64(0x0000500804020000), C64(0x0000201008040200), C64(0x0000402010080400),
	C64(0x0002040810204000), C64(0x0004081020400000), C64(0x000A102040000000), C64(0x0014224000000000),
	C64(0x0028440200000000), C64(0x0050080402000000), C64(0x0020100804020000), C64(0x0040201008040200)
};

U64 magicmovesbdb[5248];
const U64* magicmoves_b_indices[64]=
{
	magicmovesbdb+4992, magicmovesbdb+2624,  magicmovesbdb+256,  magicmovesbdb+896,
	magicmovesbdb+1280, magicmovesbdb+1664, magicmovesbdb+4800, magicmovesbdb+5120,
	magicmovesbdb+2560, magicmovesbdb+2656,  magicmovesbdb+288,  magicmovesbdb+928,
	magicmovesbdb+1312, magicmovesbdb+1696, magicmovesbdb+4832, magicmovesbdb+4928,
	magicmovesbdb+0,     magicmovesbdb+128,  magicmovesbdb+320,  magicmovesbdb+960,
	magicmovesbdb+1344, magicmovesbdb+1728, magicmovesbdb+2304, magicmovesbdb+2432,
	magicmovesbdb+32,    magicmovesbdb+160,  magicmovesbdb+448, magicmovesbdb+2752,
	magicmovesbdb+3776, magicmovesbdb+1856, magicmovesbdb+2336, magicmovesbdb+2464,
	magicmovesbdb+64,    magicmovesbdb+192,  magicmovesbdb+576, magicmovesbdb+3264,
	magicmovesbdb+4288, magicmovesbdb+1984, magicmovesbdb+2368, magicmovesbdb+2496,
	magicmovesbdb+96,    magicmovesbdb+224,  magicmovesbdb+704, magicmovesbdb+1088,
	magicmovesbdb+1472, magicmovesbdb+2112, magicmovesbdb+2400, magicmovesbdb+2528,
	magicmovesbdb+2592, magicmovesbdb+2688,  magicmovesbdb+832, magicmovesbdb+1216,
	magicmovesbdb+1600, magicmovesbdb+2240, magicmovesbdb+4864, magicmovesbdb+4960,
	magicmovesbdb+5056, magicmovesbdb+2720,  magicmovesbdb+864, magicmovesbdb+1248,
	magicmovesbdb+1632, magicmovesbdb+2272, magicmovesbdb+4896, magicmovesbdb+5184
};

U64 magicmovesrdb[102400];
const U64* magicmoves_r_indices[64]=
{
	magicmovesrdb+86016, magicmovesrdb+73728, magicmovesrdb+36864, magicmovesrdb+43008,
	magicmovesrdb+47104, magicmovesrdb+51200, magicmovesrdb+77824, magicmovesrdb+94208,
	magicmovesrdb+69632, magicmovesrdb+32768, magicmovesrdb+38912, magicmovesrdb+10240,
	magicmovesrdb+14336, magicmovesrdb+53248, magicmovesrdb+57344, magicmovesrdb+81920,
	magicmovesrdb+24576, magicmovesrdb+33792,  magicmovesrdb+6144, magicmovesrdb+11264,
	magicmovesrdb+15360, magicmovesrdb+18432, magicmovesrdb+58368, magicmovesrdb+61440,
	magicmovesrdb+26624,  magicmovesrdb+4096,  magicmovesrdb+7168,     magicmovesrdb+0,
	 magicmovesrdb+2048, magicmovesrdb+19456, magicmovesrdb+22528, magicmovesrdb+63488,
	magicmovesrdb+28672,  magicmovesrdb+5120,  magicmovesrdb+8192,  magicmovesrdb+1024,
	 magicmovesrdb+3072, magicmovesrdb+20480, magicmovesrdb+23552, magicmovesrdb+65536,
	magicmovesrdb+30720, magicmovesrdb+34816,  magicmovesrdb+9216, magicmovesrdb+12288,
	magicmovesrdb+16384, magicmovesrdb+21504, magicmovesrdb+59392, magicmovesrdb+67584,
	magicmovesrdb+71680, magicmovesrdb+35840, magicmovesrdb+39936, magicmovesrdb+13312,
	magicmovesrdb+17408, magicmovesrdb+54272, magicmovesrdb+60416, magicmovesrdb+83968,
	magicmovesrdb+90112, magicmovesrdb+75776, magicmovesrdb+40960, magicmovesrdb+45056,
	magicmovesrdb+49152, magicmovesrdb+55296, magicmovesrdb+79872, magicmovesrdb+98304
};

U64 initmagicmoves_occ(const int* squares, const int numSquares, const U64 linocc)
{
	int i;
	U64 ret=0;
	for(i=0;i<numSquares;i++)
		if(linocc&(((U64)(1))<<i)) ret|=(((U64)(1))<<squares[i]);
	return ret;
}

U64 initmagicmoves_Rmoves(const int square, const U64 occ)
{
	U64 ret=0;
	U64 bit;
	U64 rowbits=(((U64)0xFF)<<(8*(square/8)));

	bit=(((U64)(1))<<square);
	do
	{
		bit<<=8;
		ret|=bit;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	do
	{
		bit>>=8;
		ret|=bit;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	do
	{
		bit<<=1;
		if(bit&rowbits) ret|=bit;
		else break;
	}while(!(bit&occ));
	bit=(((U64)(1))<<square);
	do
	{
		bit>>=1;
		if(bit&rowbits) ret|=bit;
		else break;
	}while(!(bit&occ));
	return ret;
}

U64 initmagicmoves_Bmoves(const int square, const U64 occ)
{
	U64 ret=0;
	U64 bit;
	U64 bit2;
	U64 rowbits=(((U64)0xFF)<<(8*(square/8)));

	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit<<=8-1;
		bit2>>=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit<<=8+1;
		bit2<<=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit>>=8-1;
		bit2<<=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit>>=8+1;
		bit2>>=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	return ret;
}

#define Bmagic(square, occupancy) *(magicmoves_b_indices[square]+((((occupancy)&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>magicmoves_b_shift[square]))
#define Rmagic(square, occupancy) *(magicmoves_r_indices[square]+((((occupancy)&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>magicmoves_r_shift[square]))
#define BmagicNOMASK2(square, occupancy) *(magicmoves_b_indices2[square]+(((occupancy)*magicmoves_b_magics[square])>>magicmoves_b_shift[square]))
#define RmagicNOMASK2(square, occupancy) *(magicmoves_r_indices2[square]+(((occupancy)*magicmoves_r_magics[square])>>magicmoves_r_shift[square]))

#define Qmagic(square, occupancy) (Bmagic(square,occupancy)|Rmagic(square,occupancy))
#define QmagicNOMASK(square, occupancy) (BmagicNOMASK(square,occupancy)|RmagicNOMASK(square,occupancy))

void initmagicmoves(void)
{
	int i;

	//for bitscans :
	//initmagicmoves_bitpos64_database[(x*C64(0x07EDD5E59A4E28C2))>>58]
	int initmagicmoves_bitpos64_database[64]={
	63,  0, 58,  1, 59, 47, 53,  2,
	60, 39, 48, 27, 54, 33, 42,  3,
	61, 51, 37, 40, 49, 18, 28, 20,
	55, 30, 34, 11, 43, 14, 22,  4,
	62, 57, 46, 52, 38, 26, 32, 41,
	50, 36, 17, 19, 29, 10, 13, 21,
	56, 45, 25, 31, 35, 16,  9, 12,
	44, 24, 15,  8, 23,  7,  6,  5};

	//identical to magicmove_x_indices except without the const modifer
U64* magicmoves_b_indices2[64]=
	{
		magicmovesbdb+4992, magicmovesbdb+2624,  magicmovesbdb+256,  magicmovesbdb+896,
		magicmovesbdb+1280, magicmovesbdb+1664, magicmovesbdb+4800, magicmovesbdb+5120,
		magicmovesbdb+2560, magicmovesbdb+2656,  magicmovesbdb+288,  magicmovesbdb+928,
		magicmovesbdb+1312, magicmovesbdb+1696, magicmovesbdb+4832, magicmovesbdb+4928,
		magicmovesbdb+0,     magicmovesbdb+128,  magicmovesbdb+320,  magicmovesbdb+960,
		magicmovesbdb+1344, magicmovesbdb+1728, magicmovesbdb+2304, magicmovesbdb+2432,
		magicmovesbdb+32,    magicmovesbdb+160,  magicmovesbdb+448, magicmovesbdb+2752,
		magicmovesbdb+3776, magicmovesbdb+1856, magicmovesbdb+2336, magicmovesbdb+2464,
		magicmovesbdb+64,    magicmovesbdb+192,  magicmovesbdb+576, magicmovesbdb+3264,
		magicmovesbdb+4288, magicmovesbdb+1984, magicmovesbdb+2368, magicmovesbdb+2496,
		magicmovesbdb+96,    magicmovesbdb+224,  magicmovesbdb+704, magicmovesbdb+1088,
		magicmovesbdb+1472, magicmovesbdb+2112, magicmovesbdb+2400, magicmovesbdb+2528,
		magicmovesbdb+2592, magicmovesbdb+2688,  magicmovesbdb+832, magicmovesbdb+1216,
		magicmovesbdb+1600, magicmovesbdb+2240, magicmovesbdb+4864, magicmovesbdb+4960,
		magicmovesbdb+5056, magicmovesbdb+2720,  magicmovesbdb+864, magicmovesbdb+1248,
		magicmovesbdb+1632, magicmovesbdb+2272, magicmovesbdb+4896, magicmovesbdb+5184
	};

U64* magicmoves_r_indices2[64]=
	{
		magicmovesrdb+86016, magicmovesrdb+73728, magicmovesrdb+36864, magicmovesrdb+43008,
		magicmovesrdb+47104, magicmovesrdb+51200, magicmovesrdb+77824, magicmovesrdb+94208,
		magicmovesrdb+69632, magicmovesrdb+32768, magicmovesrdb+38912, magicmovesrdb+10240,
		magicmovesrdb+14336, magicmovesrdb+53248, magicmovesrdb+57344, magicmovesrdb+81920,
		magicmovesrdb+24576, magicmovesrdb+33792,  magicmovesrdb+6144, magicmovesrdb+11264,
		magicmovesrdb+15360, magicmovesrdb+18432, magicmovesrdb+58368, magicmovesrdb+61440,
		magicmovesrdb+26624,  magicmovesrdb+4096,  magicmovesrdb+7168,     magicmovesrdb+0,
		magicmovesrdb+2048,  magicmovesrdb+19456, magicmovesrdb+22528, magicmovesrdb+63488,
		magicmovesrdb+28672,  magicmovesrdb+5120,  magicmovesrdb+8192,  magicmovesrdb+1024,
		magicmovesrdb+3072,  magicmovesrdb+20480, magicmovesrdb+23552, magicmovesrdb+65536,
		magicmovesrdb+30720, magicmovesrdb+34816,  magicmovesrdb+9216, magicmovesrdb+12288,
		magicmovesrdb+16384, magicmovesrdb+21504, magicmovesrdb+59392, magicmovesrdb+67584,
		magicmovesrdb+71680, magicmovesrdb+35840, magicmovesrdb+39936, magicmovesrdb+13312,
		magicmovesrdb+17408, magicmovesrdb+54272, magicmovesrdb+60416, magicmovesrdb+83968,
		magicmovesrdb+90112, magicmovesrdb+75776, magicmovesrdb+40960, magicmovesrdb+45056,
		magicmovesrdb+49152, magicmovesrdb+55296, magicmovesrdb+79872, magicmovesrdb+98304
	};

	for(i=0;i<64;i++)
	{
		int squares[64];
		int numsquares=0;
		U64 temp=magicmoves_b_mask[i];
		while(temp)
		{
			U64 bit=temp&-temp;
			squares[numsquares++]=initmagicmoves_bitpos64_database[(bit*C64(0x07EDD5E59A4E28C2))>>58];
			temp^=bit;
		}
		for(temp=0;temp<(((U64)(1))<<numsquares);temp++)
		{
			U64 tempocc=initmagicmoves_occ(squares,numsquares,temp);
			BmagicNOMASK2(i,tempocc)=initmagicmoves_Bmoves(i,tempocc);
		}
	}
	for(i=0;i<64;i++)
	{
		int squares[64];
		int numsquares=0;
		U64 temp=magicmoves_r_mask[i];
		while(temp)
		{
			U64 bit=temp&-temp;
			squares[numsquares++]=initmagicmoves_bitpos64_database[(bit*C64(0x07EDD5E59A4E28C2))>>58];
			temp^=bit;
		}
		for(temp=0;temp<(((U64)(1))<<numsquares);temp++)
		{
			U64 tempocc=initmagicmoves_occ(squares,numsquares,temp);
			RmagicNOMASK2(i,tempocc)=initmagicmoves_Rmoves(i,tempocc);
		}
	}
}

// ###### MOVE GENERATION ######


void initMoveGen()
{
	initmagicmoves();

	//Initializing inBetween
	{
		int i;
		int j;
		for(i=0;i<64;i++)
			for(j=0;j<64;j++)
			{
				if(i==j)
					inBetween[i][j]=U64EMPTY;
				else if(ROW(i)==ROW(j))
				{
					U64 tempBB=i>j?toBit(i):toBit(j);
					while(!((tempBB&toBit(i)) && tempBB&toBit(j)))
						tempBB|=tempBB>>1;
					tempBB^=toBit(i)|toBit(j);
					inBetween[i][j]=tempBB;
				}
				else if(COL(i)==COL(j))
				{
					U64 tempBB=i>j?toBit(i):toBit(j);
					while(!((tempBB&toBit(i)) && tempBB&toBit(j)))
						tempBB|=tempBB>>8;
					tempBB^=toBit(i)|toBit(j);
					inBetween[i][j]=tempBB;
				}
				else if(abs(COL(i)-COL(j))==abs(ROW(i)-ROW(j)))
				{
					U64 tempBB=i>j?toBit(i):toBit(j);
					int dir;
					if(((COL(i)-COL(j))<0 && (ROW(i)-ROW(j))<0) || ((COL(i)-COL(j))>0 && (ROW(i)-ROW(j))>0))
						dir=9;
					else
						dir=7;
					while(!((tempBB&toBit(i)) && tempBB&toBit(j)))
						tempBB|=tempBB>>dir;
					tempBB^=toBit(i)|toBit(j);
					inBetween[i][j]=tempBB;
				}
				else
					inBetween[i][j]=U64EMPTY;
			}
	}

	//Initializing lineOf
	{
		int i;
		int j;
		for(i=0;i<64;i++)
			for(j=0;j<64;j++)
			{
				if(i==j)
					lineOf[i][j]=U64EMPTY;
				else if(ROW(i)==ROW(j) || COL(i)==COL(j))
				{
					lineOf[i][j]=(RmovesNoOcc(i)&RmovesNoOcc(j))|toBit(i)|toBit(j);
				}
				else if(abs(COL(i)-COL(j))==abs(ROW(i)-ROW(j)))
				{
					lineOf[i][j]=(BmovesNoOcc(i)&BmovesNoOcc(j))|toBit(i)|toBit(j);
				}
				else
					lineOf[i][j]=U64EMPTY;
			}
	}
}

//returns pieces that are possibly pinned, depending on direction of movement, to a side's king
U64 possiblePinned(const board* pos, const bool side)
{
	U64 ret=0;
	U64 possib_Pinned;
	U64 pinners;

	//Diagonal pins
	//First get a list of own pieces that can be attacked by a slider from the king position
	possib_Pinned=Bmoves(pos->KingPos[side],pos->AllPieces)&pos->PiecesSide[side];
	//xor the occupancy with the above bitboard to get a list of pinners
	pinners=Bmoves(pos->KingPos[side],pos->AllPieces^possib_Pinned)
		& ((pos->Pieces[B]|pos->Pieces[Q])&pos->PiecesSide[!side]);
	//now that we have a list of pinners, we'll figure out the bitboard of pinned pieces
	//you won't go through this loop at all if there arn't any pinned pieces
	while(pinners)
	{
		unsigned int pinnerLocation;
		GetBitAndClear(pinners, pinnerLocation);
		ret|=(inBetween(pinnerLocation,pos->KingPos[side])&possib_Pinned);
	}

	//Orthogonal pins
	possib_Pinned=Rmoves(pos->KingPos[side],pos->AllPieces)&pos->PiecesSide[side];
	pinners=Rmoves(pos->KingPos[side],pos->AllPieces^possib_Pinned)
		& ((pos->Pieces[R]|pos->Pieces[Q])&pos->PiecesSide[!side]);
	while(pinners)
	{
		unsigned int pinnerLocation;
		GetBitAndClear(pinners, pinnerLocation);
		ret|=(inBetween(pinnerLocation,pos->KingPos[side])&possib_Pinned);
	}
	return ret;
}


//generates legal evasions
void genEvasions(const board* pos, moveList* list, U64 checkers)
{
	U64 pinned;
	U64 attackers;
	unsigned int from;
	unsigned int to;
	U64 moves;
	move tempm;

	list->moveCount=0;

	//generate king moves
	#ifdef KING_MOVEGEN1
	from=pos->KingPos[pos->side];
	moves=Kmoves(from)&~(pos->PiecesSide[pos->side]);
	tempm=encodeFrom(from)|encodePiece(K)|encodePromotion(E);
	attackers=pos->AllPieces^toBit(from); //this will be used as the occupancy
	while(moves)
	{
		GetBitAndClear(moves,to);
		if(!isAttackedOcc(*pos,to,pos->side,attackers))
			list->moves[list->moveCount++].m=tempm|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
	}
	#endif
	#ifdef KING_MOVEGEN2
	{
		U64 pieceboard;
		U64 andout=pos->PiecesSide[pos->side];
		U64 attackers;

		from=pos->KingPos[pos->side];
		tempm=encodeFrom(from)|encodePiece(K)|encodePromotion(E);
		pieceboard=pos->AllPieces^toBit(from); //this will be used as the occupancy
		//King attackers
		andout|=Kmoves(pos->KingPos[pos->xside]);
		//Pawn attackers
		if(pos->xside) //if white to move
		{
			U64 pblack = piecesBLACK(*pos,P);
			andout|=((pblack&C64(0x7F7F7F7F7F7F7F7F))>>7)|((pblack&C64(0xFEFEFEFEFEFEFEFE))>>9);
		}
		else //black to move
		{
			U64 pwhite = piecesWHITE(*pos,P);
			andout|=((pwhite&C64(0x7F7F7F7F7F7F7F7F))<<9)|((pwhite&C64(0xFEFEFEFEFEFEFEFE))<<7);
		}
		//Diagonal attackers
		attackers = KBFill[from]&(pos->Pieces[B]|pos->Pieces[Q])&pos->PiecesSide[pos->xside];
		while(attackers)
		{
			unsigned int sq;
			GetBitAndClear(attackers,sq);
			andout|=Bmoves(sq,pieceboard);
		}
		//Rook attackers
		attackers = KRFill[from]&(pos->Pieces[R]|pos->Pieces[Q])&pos->PiecesSide[pos->xside];
		while(attackers)
		{
			unsigned int sq;
			GetBitAndClear(attackers,sq);
			andout|=Rmoves(sq,pieceboard);
		}
		//Knight attackers
		attackers = KNFill[from]&piecesXSide(*pos,N);
		while(attackers)
		{
			unsigned int sq;
			GetBitAndClear(attackers,sq);
			andout|=Nmoves(sq);
		}
		//Generate king moves
		moves=Kmoves(from)&(~andout);
		while(moves)
		{
			GetBitAndClear(moves,to);
			list->moves[list->moveCount++].m=tempm|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
		}
	}
	#endif

	//make sure there is only 1 checker
	if(checkers&(checkers-1)) return;

	pinned=possiblePinned(pos, pos->side);

	//generate attacks to the checker
	to=toIndex(checkers);

	//pawns
	//enpassant

	//EP moves
	if(pos->EP && (pos->side?((pos->EP+((unsigned int)8))==to):((to+((unsigned int)8))==pos->EP)))
	{
		U64 pieceboard=Pcaps[pos->xside][pos->EP]&piecesSide(*pos,P);
		while(pieceboard)
		{
			unsigned int from;
			GetBitAndClear(pieceboard,from);
			if((!(pinned&toBit(from) && !(lineOf(from,pos->KingPos[pos->side])&toBit(pos->EP)))) && /*regular pin*/
				/*pinned when removed ep*/
					!(
						/*not pinned when removed ep, rook directions*/
						(Rmoves(pos->KingPos[pos->side],pos->AllPieces^(toBit(pos->side?pos->EP+8:pos->EP-8)|toBit(from)|toBit(pos->EP))))
						&
						((pos->Pieces[R]|pos->Pieces[Q])&pos->PiecesSide[pos->xside])
						||
						/*not pinned when removed the ep, bishop directions*/
						(Bmoves(pos->KingPos[pos->side],pos->AllPieces^(toBit(pos->side?pos->EP+8:pos->EP-8)|toBit(from)|toBit(pos->EP))))
						&
						((pos->Pieces[B]|pos->Pieces[Q])&pos->PiecesSide[pos->xside])
					)
				)
				list->moves[list->moveCount++].m=encodeTo(pos->EP)|encodePiece(P)|encodeEP(pos->side?pos->EP+8:pos->EP-8)|encodeFrom(from)|encodePromotion(E)|encodeCapture(P);
		}
	}



	//regular
	attackers=attacksToP(*pos,to,pos->side)&~pinned;
	tempm=encodeTo(to)|encodePiece(P);
	while(attackers)
	{
		GetBitAndClear(attackers,from);
		list->moves[list->moveCount].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
		if(ROW(to)==7 || ROW(to)==0) //Promotion
		{
			move temp=list->moves[list->moveCount].m;
			list->moves[list->moveCount].m|=encodePromotion(Q);
			list->moveCount++;
			list->moves[list->moveCount].m=temp|encodePromotion(R);
			list->moveCount++;
			list->moves[list->moveCount].m=temp|encodePromotion(B);
			list->moveCount++;
			list->moves[list->moveCount].m=temp|encodePromotion(N);
		}
		else
			list->moves[list->moveCount].m|=encodePromotion(E);
		list->moveCount++;
	}
	attackers=attacksToN(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
	tempm=encodeTo(to)|encodePiece(N)|encodePromotion(E);
	while(attackers)
	{
		GetBitAndClear(attackers,from);
		list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
	}
	attackers=attacksToB(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
	tempm=encodeTo(to)|encodePiece(B)|encodePromotion(E);
	while(attackers)
	{
		GetBitAndClear(attackers,from);
		list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
	}
	attackers=attacksToR(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
	tempm=encodeTo(to)|encodePiece(R)|encodePromotion(E);
	while(attackers)
	{
		GetBitAndClear(attackers,from);
		list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
	}
	attackers=attacksToQ(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
	tempm=encodeTo(to)|encodePiece(Q)|encodePromotion(E);
	while(attackers)
	{
		GetBitAndClear(attackers,from);
		list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
	}

	//generate all blocking moves
	{
		U64 pieceboard;
		moves=inBetween(pos->KingPos[pos->side],to);
		//Pawn Moves

		//Double pawn moves
		pieceboard=piecesSide(*pos,P)&~pinned;
		{
			static const U64 doubleP[2] = {C64(0x000000000000FF00), C64(0x00FF000000000000)}; /*initial rank*/
			U64 pieceboard2=(pieceboard&doubleP[pos->side]);
			if(pieceboard2)
			{
				if(pos->side) //Black
				{
					pieceboard2>>=8;
					pieceboard2&=~pos->AllPieces;
					pieceboard2>>=8;
					pieceboard2&=moves;
					while(pieceboard2)
					{
						unsigned int to;
						GetBitAndClear(pieceboard2,to);
						list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+16)|encodeTo(to)|encodeCapture(E)|encodePromotion(E);
						list->moveCount++;
					}
				}
				else
				{
					pieceboard2<<=8;
					pieceboard2&=~pos->AllPieces;
					pieceboard2<<=8;
					pieceboard2&=moves;
					while(pieceboard2)
					{
						unsigned int to;
						GetBitAndClear(pieceboard2,to);
						list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-16)|encodeTo(to)|encodeCapture(E)|encodePromotion(E);
						list->moveCount++;
					}
				}
			}
		}

		//regular pawn moves
		if(pos->side) //Black
		{
			U64 pieceboard2=(pieceboard>>8)&moves;
			while(pieceboard2)
			{
				unsigned int to;
				GetBitAndClear(pieceboard2, to);
				list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+8)|encodeTo(to)|encodeCapture(E);
				if(ROW(to)==0)
				{
					move temp=list->moves[list->moveCount].m;
					list->moves[list->moveCount].m|=encodePromotion(Q);
					list->moveCount++;
					list->moves[list->moveCount].m=temp|encodePromotion(R);
					list->moveCount++;
					list->moves[list->moveCount].m=temp|encodePromotion(B);
					list->moveCount++;
					list->moves[list->moveCount].m=temp|encodePromotion(N);
				}
				else
					list->moves[list->moveCount].m|=encodePromotion(E);
				list->moveCount++;
			}
		}
		else //White
		{
			U64 pieceboard2=(pieceboard<<8)&moves;
			while(pieceboard2)
			{
				unsigned int to;
				GetBitAndClear(pieceboard2, to);
				list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-8)|encodeTo(to)|encodeCapture(E);
				if(ROW(to)==7)
				{
					move temp=list->moves[list->moveCount].m;
					list->moves[list->moveCount].m|=encodePromotion(Q);
					list->moveCount++;
					list->moves[list->moveCount].m=temp|encodePromotion(R);
					list->moveCount++;
					list->moves[list->moveCount].m=temp|encodePromotion(B);
					list->moveCount++;
					list->moves[list->moveCount].m=temp|encodePromotion(N);
				}
				else
					list->moves[list->moveCount].m|=encodePromotion(E);
				list->moveCount++;
			}
		}

		//regular piece moves
		while(moves)
		{
			GetBitAndClear(moves,to);
			attackers=attacksToN(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
			tempm=encodeTo(to)|encodePiece(N)|encodePromotion(E);
			while(attackers)
			{
				GetBitAndClear(attackers,from);
				list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
			}
			attackers=attacksToB(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
			tempm=encodeTo(to)|encodePiece(B)|encodePromotion(E);
			while(attackers)
			{
				GetBitAndClear(attackers,from);
				list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
			}
			attackers=attacksToR(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
			tempm=encodeTo(to)|encodePiece(R)|encodePromotion(E);
			while(attackers)
			{
				GetBitAndClear(attackers,from);
				list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
			}
			attackers=attacksToQ(*pos,to)&pos->PiecesSide[pos->side]&~pinned;
			tempm=encodeTo(to)|encodePiece(Q)|encodePromotion(E);
			while(attackers)
			{
				GetBitAndClear(attackers,from);
				list->moves[list->moveCount++].m=tempm|encodeFrom(from)|encodeCapture(pos->PieceTypes[to]);
			}
		}

	} //generating blocking moves (end)
}


//generates legal moves
void genMoves(const board* pos, moveList* list)
{
	U64 pieceboard;
	U64 pinned;
	static const U64 castlingPassover[2][2]=
	{
		{((U64)0x3)<<5,((U64)0x3)<<2},
		{((U64)0x3)<<(56+5),((U64)0x3)<<(56+2)}
	};
	static const U64 castlingEmptySquares[2][2]=
	{
		{((U64)0x3)<<5,((U64)0x7)<<1},
		{((U64)0x3)<<(56+5),((U64)0x7)<<(56+1)}
	};
	U64 piecesCurrentSide;
	list->moveCount=0;

	//piecesCurrentSide is used as a temporary here
	if((piecesCurrentSide=inCheck(*pos,pos->side)))
	{
		genEvasions(pos,list,piecesCurrentSide);
		return;
	}

	piecesCurrentSide=pos->PiecesSide[pos->side];
	pinned=possiblePinned(pos,pos->side);

	//Castling moves
	{
		unsigned int temp;
		if((temp=canCastle(*pos,pos->side)) && !inCheck(*pos,pos->side))
		{
			U64 squares;
			//if Kingside available and pieces clear
			if(temp&1 && !(castlingEmptySquares[pos->side][KINGSIDE] & (pos->AllPieces)))
			{
				squares=castlingPassover[pos->side][KINGSIDE];
				//optimize this
				bool kdone = false;
				while(!kdone && squares)
				{
					unsigned int sq;
					GetBitAndClear(squares,sq);
					if(isAttacked(*pos,sq,pos->side)) kdone=true;   //go to "kdone:"
				}
				if(!kdone) {
                    list->moves[list->moveCount].m=KingsideCastle;
                    list->moveCount++;
				}
			}
	//label kdone:

			//if Queenside available and pieces clear
			if(temp&2 && !(castlingEmptySquares[pos->side][QUEENSIDE]&(pos->AllPieces)))
			{
				squares=castlingPassover[pos->side][QUEENSIDE];
				//optimize this
				bool castlingdone = false;
				while(!castlingdone && squares)
				{
					unsigned int sq;
					GetBitAndClear(squares,sq);
					if(isAttacked(*pos,sq,pos->side)) castlingdone=true;    //go to "castlingdone:"
				}
				if(!castlingdone) {
                    list->moves[list->moveCount].m=QueensideCastle;
                    list->moveCount++;
				}
			}
		}
	}

	// label castlingdone:

	//EP moves
	if(pos->EP)
	{
		pieceboard=Pcaps[pos->xside][pos->EP]&pos->Pieces[P]&piecesCurrentSide;
		while(pieceboard)
		{
			unsigned int from;
			GetBitAndClear(pieceboard,from);
			if((!(pinned&toBit(from) && !(lineOf(from,pos->KingPos[pos->side])&toBit(pos->EP)))) && /*regular pin*/
				/*pinned when removed ep*/
					!(
						/*not pinned when removed ep, rook directions*/
						(Rmoves(pos->KingPos[pos->side],pos->AllPieces^(toBit(pos->side?pos->EP+8:pos->EP-8)|toBit(from)|toBit(pos->EP))))
						&
						((pos->Pieces[R]|pos->Pieces[Q])&pos->PiecesSide[pos->xside])
						||
						/*not pinned when removed the ep, bishop directions*/
						(Bmoves(pos->KingPos[pos->side],pos->AllPieces^(toBit(pos->side?pos->EP+8:pos->EP-8)|toBit(from)|toBit(pos->EP))))
						&
						((pos->Pieces[B]|pos->Pieces[Q])&pos->PiecesSide[pos->xside])
					)
				)
				list->moves[list->moveCount++].m=encodeTo(pos->EP)|encodePiece(P)|encodeEP(pos->side?pos->EP+8:pos->EP-8)|encodeFrom(from)|encodePromotion(E)|encodeCapture(P);
		}
	}

	//Pawn Moves
	pieceboard=pos->Pieces[P]&piecesCurrentSide&~pinned;
	//Double moves (not pinned)
	{
		static const U64 doubleP[2] = {C64(0x000000000000FF00), C64(0x00FF000000000000)}; /*initial rank*/
		U64 pieceboard2=(pieceboard&doubleP[pos->side]);
		if(pieceboard2)
		{
			if(pos->side) //Black
			{
				pieceboard2>>=8;
				pieceboard2&=~pos->AllPieces;
				pieceboard2>>=8;
				pieceboard2&=~pos->AllPieces;
				while(pieceboard2)
				{
					unsigned int to;
					GetBitAndClear(pieceboard2,to);
					list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+16)|encodeTo(to)|encodeCapture(E)|encodePromotion(E);
					list->moveCount++;
				}
			}
			else
			{
				pieceboard2<<=8;
				pieceboard2&=~pos->AllPieces;
				pieceboard2<<=8;
				pieceboard2&=~pos->AllPieces;
				while(pieceboard2)
				{
					unsigned int to;
					GetBitAndClear(pieceboard2,to);
					list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-16)|encodeTo(to)|encodeCapture(E)|encodePromotion(E);
					list->moveCount++;
				}
			}
		}
	}
	pieceboard=pos->Pieces[P]&piecesCurrentSide&pinned;
	//Double moves (pinned)
	{
		static const U64 doubleP[2] = {C64(0x000000000000FF00), C64(0x00FF000000000000)}; /*initial rank*/
		U64 pieceboard2=(pieceboard&doubleP[pos->side]);
		if(pieceboard2)
		{
			if(pos->side) //Black
			{
				pieceboard2>>=8;
				pieceboard2&=~pos->AllPieces;
				pieceboard2>>=8;
				pieceboard2&=~pos->AllPieces;
				while(pieceboard2)
				{
					unsigned int to;
					GetBitAndClear(pieceboard2,to);
					if(lineOf(to+16,pos->KingPos[pos->side])&toBit(to))
						list->moves[list->moveCount++].m=encodePiece(P)|encodeFrom(to+16)|encodeTo(to)|encodeCapture(E)|encodePromotion(E);
				}
			}
			else
			{
				pieceboard2<<=8;
				pieceboard2&=~pos->AllPieces;
				pieceboard2<<=8;
				pieceboard2&=~pos->AllPieces;
				while(pieceboard2)
				{
					unsigned int to;
					GetBitAndClear(pieceboard2,to);
					if(lineOf(to-16,pos->KingPos[pos->side])&toBit(to))
						list->moves[list->moveCount++].m=encodePiece(P)|encodeFrom(to-16)|encodeTo(to)|encodeCapture(E)|encodePromotion(E);
				}
			}
		}
	}

	//Single Moves (not pinned)
	pieceboard=pos->Pieces[P]&piecesCurrentSide&~pinned;
	if(pos->side) //Black
	{
		U64 pieceboard2=(pieceboard>>8)&~pos->AllPieces;
		U64 pieceboardCap1=((pieceboard>>7)&C64(0xFEFEFEFEFEFEFEFE))&pos->PiecesSide[pos->xside];
		U64 pieceboardCap2=((pieceboard>>9)&C64(0x7F7F7F7F7F7F7F7F))&pos->PiecesSide[pos->xside];
		while(pieceboard2)
		{
			unsigned int to;
			GetBitAndClear(pieceboard2, to);
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+8)|encodeTo(to)|encodeCapture(E);
			if(ROW(to)==0)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap1)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap1, to);
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+7)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==0)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap2)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap2, to);
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+9 )|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==0)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
	}
	else //White
	{
		U64 pieceboard2=(pieceboard<<8)&~pos->AllPieces;
		U64 pieceboardCap1=((pieceboard<<9)&C64(0xFEFEFEFEFEFEFEFE))&pos->PiecesSide[pos->xside];
		U64 pieceboardCap2=((pieceboard<<7)&C64(0x7F7F7F7F7F7F7F7F))&pos->PiecesSide[pos->xside];
		while(pieceboard2)
		{
			unsigned int to;
			GetBitAndClear(pieceboard2, to);
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-8)|encodeTo(to)|encodeCapture(E);
			if(ROW(to)==7)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap1)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap1, to);
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-9)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==7)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap2)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap2, to);
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-7)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==7)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
	}

	//Single Moves (pinned)
	pieceboard=pos->Pieces[P]&piecesCurrentSide&pinned;
	if(pos->side) //Black
	{
		U64 pieceboard2=(pieceboard>>8)&~pos->AllPieces;
		U64 pieceboardCap1=((pieceboard>>7)&C64(0xFEFEFEFEFEFEFEFE))&pos->PiecesSide[pos->xside];
		U64 pieceboardCap2=((pieceboard>>9)&C64(0x7F7F7F7F7F7F7F7F))&pos->PiecesSide[pos->xside];
		while(pieceboard2)
		{
			unsigned int to;
			GetBitAndClear(pieceboard2, to);
			if(!(lineOf(to+8,pos->KingPos[pos->side])&toBit(to))) continue;
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+8)|encodeTo(to)|encodeCapture(E);
			if(ROW(to)==0)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap1)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap1, to);
			if(!(lineOf(to+7,pos->KingPos[pos->side])&toBit(to))) continue;
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+7)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==0)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap2)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap2, to);
			if(!(lineOf(to+9,pos->KingPos[pos->side])&toBit(to))) continue;
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to+9)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==0)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
	}
	else //White
	{
		U64 pieceboard2=(pieceboard<<8)&~pos->AllPieces;
		U64 pieceboardCap1=((pieceboard<<9)&C64(0xFEFEFEFEFEFEFEFE))&pos->PiecesSide[pos->xside];
		U64 pieceboardCap2=((pieceboard<<7)&C64(0x7F7F7F7F7F7F7F7F))&pos->PiecesSide[pos->xside];
		while(pieceboard2)
		{
			unsigned int to;
			GetBitAndClear(pieceboard2, to);
			if(!(lineOf(to-8,pos->KingPos[pos->side])&toBit(to))) continue;
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-8)|encodeTo(to)|encodeCapture(E);
			if(ROW(to)==7)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap1)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap1, to);
			if(!(lineOf(to-9,pos->KingPos[pos->side])&toBit(to))) continue;
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-9)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==7)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
		while(pieceboardCap2)
		{
			unsigned int to;
			GetBitAndClear(pieceboardCap2, to);
			if(!(lineOf(to-7,pos->KingPos[pos->side])&toBit(to))) continue;
			list->moves[list->moveCount].m=encodePiece(P)|encodeFrom(to-7)|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			if(ROW(to)==7)
			{
				move temp=list->moves[list->moveCount].m;
				list->moves[list->moveCount].m|=encodePromotion(Q);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(R);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(B);
				list->moveCount++;
				list->moves[list->moveCount].m=temp|encodePromotion(N);
			}
			else
				list->moves[list->moveCount].m|=encodePromotion(E);
			list->moveCount++;
		}
	}

	//Regular moves (first not pinned, then pinned for each piece)
	pieceboard=pos->Pieces[N]&piecesCurrentSide&~pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Nmoves(from)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(N)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			list->moves[list->moveCount].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			list->moveCount++;
		}
	}
	pieceboard=pos->Pieces[B]&piecesCurrentSide&~pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Bmoves(from,pos->AllPieces)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(B)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			list->moves[list->moveCount].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			list->moveCount++;
		}
	}
	pieceboard=pos->Pieces[B]&piecesCurrentSide&pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Bmoves(from,pos->AllPieces)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(B)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			if(lineOf(from,pos->KingPos[pos->side])&toBit(to))
				list->moves[list->moveCount++].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
		}
	}
	pieceboard=pos->Pieces[R]&piecesCurrentSide&~pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Rmoves(from,/*pos->AllPieces*/0);
		moves=Rmoves(from,pos->AllPieces)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(R)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			list->moves[list->moveCount].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			list->moveCount++;
		}
	}
	pieceboard=pos->Pieces[R]&piecesCurrentSide&pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Rmoves(from,/*pos->AllPieces*/0);
		moves=Rmoves(from,pos->AllPieces)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(R)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			if(lineOf(from,pos->KingPos[pos->side])&toBit(to))
				list->moves[list->moveCount++].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
		}
	}
	pieceboard=pos->Pieces[Q]&piecesCurrentSide&~pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Qmoves(from,pos->AllPieces)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(Q)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			list->moves[list->moveCount].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
			list->moveCount++;
		}
	}
	pieceboard=pos->Pieces[Q]&piecesCurrentSide&pinned;
	while(pieceboard)
	{
		unsigned int from;
		U64 moves;
		move temp;
		GetBitAndClear(pieceboard,from);
		moves=Qmoves(from,pos->AllPieces)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(Q)|encodePromotion(E);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			if(lineOf(from,pos->KingPos[pos->side])&toBit(to))
				list->moves[list->moveCount++].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
		}
	}

	//only 1 king
	#ifdef KING_MOVEGEN1
	{
		unsigned int from;
		U64 moves;
		move temp;
		from=pos->KingPos[pos->side];
		moves=Kmoves(from)&~(pos->PiecesSide[pos->side]);
		temp=encodeFrom(from)|encodePiece(K)|encodePromotion(E);
		pieceboard=pos->AllPieces^toBit(from); //this will be used as the occupancy

		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			if(!isAttackedOcc(*pos,to,pos->side,pieceboard))
				list->moves[list->moveCount++].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
		}
	}
	#endif

	#ifdef KING_MOVEGEN2
	{
		unsigned int from;
		U64 moves;
		U64 andout=pos->PiecesSide[pos->side];
		U64 attackers;
		move temp;
		from=pos->KingPos[pos->side];
		temp=encodeFrom(from)|encodePiece(K)|encodePromotion(E);
		pieceboard=pos->AllPieces^toBit(from); //this will be used as the occupancy
		//King attackers
		andout|=Kmoves(pos->KingPos[pos->xside]);
		//Pawn attackers
		if(pos->xside) //if white to move
		{
			U64 pblack = piecesBLACK(*pos,P);
			andout|=((pblack&C64(0x7F7F7F7F7F7F7F7F))>>7)|((pblack&C64(0xFEFEFEFEFEFEFEFE))>>9);
		}
		else //black to move
		{
			U64 pwhite = piecesWHITE(*pos,P);
			andout|=((pwhite&C64(0x7F7F7F7F7F7F7F7F))<<9)|((pwhite&C64(0xFEFEFEFEFEFEFEFE))<<7);
		}
		//Diagonal attackers
		attackers = KBFill[from]&(pos->Pieces[B]|pos->Pieces[Q])&pos->PiecesSide[pos->xside];
		while(attackers)
		{
			unsigned int sq;
			GetBitAndClear(attackers,sq);
			andout|=Bmoves(sq,pieceboard);
		}
		//Rook attackers
		attackers = KRFill[from]&(pos->Pieces[R]|pos->Pieces[Q])&pos->PiecesSide[pos->xside];
		while(attackers)
		{
			unsigned int sq;
			GetBitAndClear(attackers,sq);
			andout|=Rmoves(sq,pieceboard);
		}
		//Knight attackers
		attackers = KNFill[from]&piecesXSide(*pos,N);
		while(attackers)
		{
			unsigned int sq;
			GetBitAndClear(attackers,sq);
			andout|=Nmoves(sq);
		}
		//Generate king moves
		moves=Kmoves(from)&(~andout);
		while(moves)
		{
			unsigned int to;
			GetBitAndClear(moves,to);
			list->moves[list->moveCount++].m=temp|encodeTo(to)|encodeCapture(pos->PieceTypes[to]);
		}
	}
	#endif
}

// #####
//
// Position: set by fen, move, get fen

// #####



unsigned int moveNumber;

char pieceToCharUC[NUMPIECETYPES+1]={'P','N','B','R','Q','K',' '};
char pieceToCharLC[NUMPIECETYPES+1]={'p','n','b','r','q','k',' '};

#define pieceToChar(piece) pieceToCharUC[piece]
#define pieceToCharUC(piece) pieceToCharUC[piece]
#define pieceToCharLC(piece) pieceToCharLC[piece]

/*returns -1 if the coordiate is invalid*/
int coordToSquare(const char* coord)
{
	int i;
	if(!(coord[1]>='1' && coord[1]<='8'))
		return -1;
	i=8*(coord[1]-'1');
	if(coord[0]>='a' && coord[0]<='h')
		return i+(coord[0]-'a');
	else if(coord[0]>='A' && coord[0]<='H')
		return i+(coord[0]-'A');
	return -1;
}

unsigned char charToPiece(char c)
{
	switch(c)
	{
		case 'p':case'P':return P;
		case 'n':case'N':return N;
		case 'b':case'B':return B;
		case 'r':case'R':return R;
		case 'q':case'Q':return Q;
		case 'k':case'K':return K;
		default: return E;
	}
}


// get FEN position to string
void getboard(board* pos, char *s)
{
	int r;
	int c;
	int i=0;
	for(r=56;r>=0;r-=8)
	{
		int emptySquares=0;
		for(c=0;c<8;c++)
		{
			if(toBit(r+c)&pos->PiecesSide[WHITE])
			{
				if(emptySquares)
				{
					s[i++]=('0'+emptySquares);
					emptySquares=0;
				}
				s[i++]=pieceToCharUC(pos->PieceTypes[r+c]);
			}
			else if(toBit(r+c)&pos->PiecesSide[BLACK])
			{
				if(emptySquares)
				{
					s[i++]=('0'+emptySquares);
					emptySquares=0;
				}
				s[i++]=pieceToCharLC(pos->PieceTypes[r+c]);
			}
			else
				emptySquares++;
		}
		if(emptySquares)
			s[i++]=('0'+emptySquares);
		if(r) s[i++]='/';
	}
	if(pos->side) {
            s[i++]=' '; s[i++]='b'; s[i++]=' ';
            }
	else  {
            s[i++]=' '; s[i++]='w'; s[i++]=' ';
            }
	if(!pos->castling) s[i++]='-';
	else
	{
		if(pos->castling&WK) s[i++]='K';
		if(pos->castling&WQ) s[i++]='Q';
		if(pos->castling&BK) s[i++]='k';
		if(pos->castling&BQ) s[i++]='q';
	}
	if(!pos->EP) {
            s[i++]=' '; s[i++]='-'; s[i++]=' ';
            }
	else  {
            s[i++]=' '; s[i++]='a'+COL(pos->EP); s[i++]='1'+ROW(pos->EP); s[i++]=' ';
            }
    sprintf(&s[i],"%d %d",pos->fifty, (moveNumber>>1)+1);
}


//setboard using Forsyth-Edwards Notation
void setboard(board* pos, char* s)
{
	//rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
	char piecePlacement[100];
	char activeColor[2];
	char castlingAvailability[20];
	char enPassantSquare[12];
	char halfMoveClock[12];
	char fullMoveNumber[12];
	unsigned char i,k;
	signed char j;

    // clear board
    pos->AllPieces = C64(0x0000000000000000);
	pos->PiecesSide[WHITE]=C64(0x0000000000000000);
	pos->PiecesSide[BLACK]=C64(0x0000000000000000);
	pos->KingPos[WHITE]=E1;
	pos->KingPos[BLACK]=E8;
    for(i=0;i<NUMPIECETYPES;i++) pos->Pieces[i]=C64(0x0000000000000000);
    for(i=0;i<64;i++) pos->PieceTypes[i] = NOPIECE;

	sscanf(s,"%s %s %s %s %s %s",piecePlacement,activeColor,castlingAvailability,enPassantSquare,halfMoveClock,fullMoveNumber);

	//parse piece placement data
	for(i=0,j=56,k=0;piecePlacement[i]!=0 && j>=0;i++)
	{
		switch(piecePlacement[i])
		{
		case 'P':
			pos->PieceTypes[j+k]=P;
			pos->Pieces[P]^=toBit(j+k);
			pos->PiecesSide[WHITE]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'p':
			pos->PieceTypes[j+k]=P;
			pos->Pieces[P]^=toBit(j+k);
			pos->PiecesSide[BLACK]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'N':
			pos->PieceTypes[j+k]=N;
			pos->Pieces[N]^=toBit(j+k);
			pos->PiecesSide[WHITE]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'n':
			pos->PieceTypes[j+k]=N;
			pos->Pieces[N]^=toBit(j+k);
			pos->PiecesSide[BLACK]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'B':
			pos->PieceTypes[j+k]=B;
			pos->Pieces[B]^=toBit(j+k);
			pos->PiecesSide[WHITE]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'b':
			pos->PieceTypes[j+k]=B;
			pos->Pieces[B]^=toBit(j+k);
			pos->PiecesSide[BLACK]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'R':
			pos->PieceTypes[j+k]=R;
			pos->Pieces[R]^=toBit(j+k);
			pos->PiecesSide[WHITE]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'r':
			pos->PieceTypes[j+k]=R;
			pos->Pieces[R]^=toBit(j+k);
			pos->PiecesSide[BLACK]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'Q':
			pos->PieceTypes[j+k]=Q;
			pos->Pieces[Q]^=toBit(j+k);
			pos->PiecesSide[WHITE]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'q':
			pos->PieceTypes[j+k]=Q;
			pos->Pieces[Q]^=toBit(j+k);
			pos->PiecesSide[BLACK]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			k++;
			break;
		case 'K':
			pos->PieceTypes[j+k]=K;
			pos->Pieces[K]^=toBit(j+k);
			pos->PiecesSide[WHITE]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			pos->KingPos[WHITE]=(j+k);
			k++;
			break;
		case 'k':
			pos->PieceTypes[j+k]=K;
			pos->Pieces[K]^=toBit(j+k);
			pos->PiecesSide[BLACK]^=toBit(j+k);
			pos->AllPieces^=toBit(j+k);
			pos->KingPos[BLACK]=(j+k);
			k++;
			break;
		case '\\':
		case '/':
			k=0;
			j-=8;
			break;
		case '1': k+=1; break;
		case '2': k+=2; break;
		case '3': k+=3; break;
		case '4': k+=4; break;
		case '5': k+=5; break;
		case '6': k+=6; break;
		case '7': k+=7; break;
		case '8': k+=8; break;
		default:
			return;
		}
	}

	//parse active color
	switch(*activeColor)
	{
	case 'b':
	case 'B':
		pos->side=BLACK;
		pos->xside=WHITE;
		break;
	default:
		pos->side=WHITE;
		pos->xside=BLACK;
		break;
	}

	pos->castling=0;

	//castling availability
	for(i=0;castlingAvailability[i]!=0;i++)
	{
		switch(castlingAvailability[i])
		{
		case 'K':
			if(piecesWHITE(*pos,R)&toBit(H1) && pos->KingPos[WHITE]==E1)
				pos->castling|=WK;
			break;
		case 'Q':
			if(piecesWHITE(*pos,R)&toBit(A1) && pos->KingPos[WHITE]==E1)
				pos->castling|=WQ;
			break;
		case 'k':
			if(piecesBLACK(*pos,R)&toBit(H8) && pos->KingPos[BLACK]==E8)
				pos->castling|=BK;
			break;
		case 'q':
			if(piecesBLACK(*pos,R)&toBit(A8) && pos->KingPos[BLACK]==E8)
				pos->castling|=BQ;
			break;
		}
	}

	pos->EP=0;

	//enPassantSquare
	if(*enPassantSquare!='-')
	{
		int tempSq=coordToSquare(enPassantSquare);
		if(tempSq>=0)
			pos->EP=(unsigned char)tempSq;
	}

	pos->fifty=0;

	//halfmove clock
	if(*halfMoveClock!='-')
	{
		int tempClock;
		if(sscanf(halfMoveClock,"%d",&tempClock)==1)
			pos->fifty=(unsigned char)tempClock;
	}

    moveNumber=0;

	if(*fullMoveNumber!='-')
	{
		unsigned int tempFMN;
		if(sscanf(fullMoveNumber,"%u",&tempFMN)==1) {
			moveNumber=2*(tempFMN-1)+pos->side;
		}
	}

}

// to set starting position

void startingpos(board* pos) {
    static char *chess_sFEN/*57*/ = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\0";
    setboard( pos, chess_sFEN );
}


void makemove(board* pos, const move m)
{
	const unsigned int to=extractTo(m), piece=extractPiece(m), capture=extractCapture(m), from=extractFrom(m);
	U64 temp=toBit(from)^toBit(to);

	//fifty move rule
	pos->fifty++;

	if(pos->EP) //clear ep flag
	{
		pos->EP=0;
	}

	//Castling specific code
	if(pos->castling)
	{
		if(piece==E) //castling
		{
			if(pos->side) //BLACK
			{
				if(pos->castling&BK)
				{
					pos->castling^=BK;
				}
				if(pos->castling&BQ)
				{
					pos->castling^=BQ;
				}
				if(m==KingsideCastle)
				{
					pos->Pieces[K]^=toBit(E8)|toBit(G8);
					pos->Pieces[R]^=toBit(H8)|toBit(F8);
					pos->AllPieces^=toBit(E8)|toBit(G8)|toBit(H8)|toBit(F8);
					pos->PiecesSide[BLACK]^=toBit(E8)|toBit(G8)|toBit(H8)|toBit(F8);
					pos->PieceTypes[E8]=E;
					pos->PieceTypes[G8]=K;
					pos->PieceTypes[H8]=E;
					pos->PieceTypes[F8]=R;
					pos->KingPos[BLACK]=G8;
				}
				else //QueensideCastle
				{
					pos->Pieces[K]^=toBit(E8)|toBit(C8);
					pos->Pieces[R]^=toBit(A8)|toBit(D8);
					pos->AllPieces^=toBit(E8)|toBit(C8)|toBit(A8)|toBit(D8);
					pos->PiecesSide[BLACK]^=toBit(E8)|toBit(C8)|toBit(A8)|toBit(D8);
					pos->PieceTypes[E8]=E;
					pos->PieceTypes[C8]=K;
					pos->PieceTypes[A8]=E;
					pos->PieceTypes[D8]=R;
					pos->KingPos[BLACK]=C8;
				}
			}
			else //WHITE
			{
				if(pos->castling&WK)
				{
					pos->castling^=WK;
				}
				if(pos->castling&WQ)
				{
					pos->castling^=WQ;
				}
				if(m==KingsideCastle)
				{
					pos->Pieces[K]^=toBit(E1)|toBit(G1);
					pos->Pieces[R]^=toBit(H1)|toBit(F1);
					pos->AllPieces^=toBit(E1)|toBit(G1)|toBit(H1)|toBit(F1);
					pos->PiecesSide[WHITE]^=toBit(E1)|toBit(G1)|toBit(H1)|toBit(F1);
					pos->PieceTypes[E1]=E;
					pos->PieceTypes[G1]=K;
					pos->PieceTypes[H1]=E;
					pos->PieceTypes[F1]=R;
					pos->KingPos[WHITE]=G1;
				}
				else //QueensideCastle
				{
					pos->Pieces[K]^=toBit(E1)|toBit(C1);
					pos->Pieces[R]^=toBit(A1)|toBit(D1);
					pos->AllPieces^=toBit(E1)|toBit(C1)|toBit(A1)|toBit(D1);
					pos->PiecesSide[WHITE]^=toBit(E1)|toBit(C1)|toBit(A1)|toBit(D1);
					pos->PieceTypes[E1]=E;
					pos->PieceTypes[C1]=K;
					pos->PieceTypes[A1]=E;
					pos->PieceTypes[D1]=R;
					pos->KingPos[WHITE]=C1;
				}
			}
			pos->side=pos->xside;
			pos->xside=!pos->xside;
			return;
		}
		if(piece==R) //adjust castling if rook moved
		{
			if(pos->side) //BLACK
			{
				if(from==A8 && pos->castling&BQ)
				{
					pos->castling&=~BQ;
				}
				else if(from==H8 && pos->castling&BK)
				{
					pos->castling&=~BK;
				}
			}
			else //WHITE
			{
				if(from==A1 && pos->castling&WQ)
				{
					pos->castling&=~WQ;
				}
				else if(from==H1 && pos->castling&WK)
				{
					pos->castling&=~WK;
				}
			}
		}
		else if(piece==K) //adjust castling if king moved
		{
			if(pos->side) //Black
			{
				if(pos->castling&BK)
				{
					pos->castling^=BK;
				}
				if(pos->castling&BQ)
				{
					pos->castling^=BQ;
				}
			}
			else
			{
				if(pos->castling&WK)
				{
					pos->castling^=WK;
				}
				if(pos->castling&WQ)
				{
					pos->castling^=WQ;
				}
			}
		}
		if(capture==R) //adjust castling if rook got captured
		{
			if(pos->xside) //If BLACK got captured
			{

				if(to==A8 && pos->castling&BQ)
				{
					pos->castling&=~BQ;
				}
				else if(to==H8 && pos->castling&BK)
				{
					pos->castling&=~BK;
				}
			}
			else
			{
				if(to==A1 && pos->castling&WQ)
				{
					pos->castling&=~WQ;
				}
				else if(to==H1 && pos->castling&WK)
				{
					pos->castling&=~WK;
				}
			}
		}
	}

	if(piece==K)
		pos->KingPos[pos->side]=(unsigned char)to;

	//Generic code
	if(capture!=E)
	{
		pos->fifty=0;
		pos->PiecesSide[pos->xside]^=toBit(to);
		pos->Pieces[piece]^=temp;
		pos->Pieces[capture]^=toBit(to);
		pos->AllPieces^=toBit(from);
		pos->PiecesSide[pos->side]^=temp;
		pos->PieceTypes[from]=E;
		pos->PieceTypes[to]=(unsigned char)piece;

	}
	else
	{
		pos->Pieces[piece]^=temp;
		pos->AllPieces^=temp;
		pos->PiecesSide[pos->side]^=temp;
		pos->PieceTypes[from]=E;
		pos->PieceTypes[to]=(unsigned char)piece;
	}

	//Special code for pawns
	if(piece==P)
	{
		unsigned int enpassant=extractEP(m);
		unsigned int promotion=extractPromotion(m);
		pos->fifty=0;
		if(to==from+16  && Pcaps(from+8,WHITE)&piecesBLACK(*pos,P))
		{
			pos->EP=(unsigned char)(from+8);
		}
		else if(from==to+16 && Pcaps(to+8,BLACK)&piecesWHITE(*pos,P))
		{
			pos->EP=(unsigned char)(to+8);
		}
		else if(enpassant!=0) //Remove the pawn
		{
			pos->Pieces[P]^=toBit(enpassant)|toBit(to);
			pos->AllPieces^=toBit(enpassant)|toBit(to);
			pos->PiecesSide[pos->xside]^=toBit(enpassant)|toBit(to);
			pos->PieceTypes[enpassant]=E;
		}
		else if(promotion!=E)
		{
			pos->PieceTypes[to]=(unsigned char)promotion;
			pos->Pieces[P]^=toBit(to);
			pos->Pieces[promotion]^=toBit(to);
		}
	}
	pos->side=!pos->side;
	pos->xside=!pos->xside;

}

char m2strSgn;      // to save the sign +,#

void moveToString(board* pos, const move m, char* s)
{
	unsigned int piece=extractPiece(m), from=extractFrom(m), to=extractTo(m), capture=extractCapture(m),
		 promotion=extractPromotion(m);

	int i=0;

	if(piece==E) //castling
	{
        s[i++]='0'; s[i++]='-'; s[i++]='0';

		if(m!=KingsideCastle) {
            s[i++]='-'; s[i++]='0';
		}
	}
    else {

	if(piece!=P)
        {
        s[i++]=pieceToChar(piece);
        }
	s[i++]='a'+(char)COL(from);
	s[i++]='1'+(char)ROW(from);

	s[i++]=((capture!=E) ? 'x' : '-' );

	s[i++]='a'+(char)COL(to);
	s[i++]='1'+(char)ROW(to);
	if(piece==P && promotion!=E)
            {
			s[i++]='=';
			s[i++]=pieceToChar(promotion);
            }
    }

    // check+ and checkmate# signs

    m2strSgn = 0;
    board tmpBo, *p=&tmpBo;
    copyboardTo(p, pos);

    makemove(p,m);
    if(inCheck(*p,p->side)) {
        moveList ml;
       	genMoves(p,&ml);
        m2strSgn = (ml.moveCount==0 ? '#' : '+');
        s[i++]=m2strSgn;
    }

	s[i++]='\0';
}

void SeeLegalMoves(board *pos) {
			unsigned int i;
			moveList ml;
			char movestr[12];

			genMoves(pos,&ml);
			for(i=0;i<ml.moveCount;i++)
			{
				moveToString(pos, ml.moves[i].m, movestr);
				printf("%2d) %s\n",i+1,movestr);
			}
}

/* To print chess board to string */
void dispboard_s(board *pos, char *s) {
 int i=0,j;
 char fen[200];
 char *w=fen;
 getboard(pos,fen);
 while(*w!=' ') {
    if(*w>'0' && *w<'9') {
        for(j =(*w)-'0'; j>0; j--) {
            s[i++]='.';
        }
    }
    else {
        if(*w=='/') s[i++]='\n';
        else s[i++]=*w;
        }
    w++;
    }
 s[i]=0;
 }
